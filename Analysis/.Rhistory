hitVec <- rep(0,15)
tMat.goal <- tMat
tMat.goal[goal[toti],] <- 0
for(s in stepsleft[toti]:1){
hitC <- I %*% matrix.power(tMat.goal, s)
hitVec[s] <- hitC[goal[toti]]
}
opt.EV[toti] <- sum(hitVec)*winM + (1-sum(hitVec)) * loseM
}
}
opt.choice <- as.numeric(opt.EV>0)
opt.choice[which(opt.choice==0)] <- -1
return(opt.choice)
}
#################################################################################
## Analyze proportion of normative choices
a <- 0.25
tMat <- rbind(c(0,a,a,a,0,0,0,0,0,0,0,0,0,0,a),
c(a,0,a,a,a,0,0,0,0,0,0,0,0,0,0),
c(a,a,0,a,a,0,0,0,0,0,0,0,0,0,0),
c(a,a,a,0,a,0,0,0,0,0,0,0,0,0,0),
c(0,a,a,a,0,a,0,0,0,0,0,0,0,0,0),
c(0,0,0,0,a,0,a,a,a,0,0,0,0,0,0),
c(0,0,0,0,0,a,0,a,a,a,0,0,0,0,0),
c(0,0,0,0,0,a,a,0,a,a,0,0,0,0,0),
c(0,0,0,0,0,a,a,a,0,a,0,0,0,0,0),
c(0,0,0,0,0,0,a,a,a,0,a,0,0,0,0),
c(0,0,0,0,0,0,0,0,0,a,0,a,a,a,0),
c(0,0,0,0,0,0,0,0,0,0,a,0,a,a,a),
c(0,0,0,0,0,0,0,0,0,0,a,a,0,a,a),
c(0,0,0,0,0,0,0,0,0,0,a,a,a,0,a),
c(a,0,0,0,0,0,0,0,0,0,0,a,a,a,0))
get.opt.choice(1, 3, 5, 12, tMat, 1, 1)
#################################################################################
## Analyze proportion of normative choices
library(matrixcalc)
a <- 0.25
tMat <- rbind(c(0,a,a,a,0,0,0,0,0,0,0,0,0,0,a),
c(a,0,a,a,a,0,0,0,0,0,0,0,0,0,0),
c(a,a,0,a,a,0,0,0,0,0,0,0,0,0,0),
c(a,a,a,0,a,0,0,0,0,0,0,0,0,0,0),
c(0,a,a,a,0,a,0,0,0,0,0,0,0,0,0),
c(0,0,0,0,a,0,a,a,a,0,0,0,0,0,0),
c(0,0,0,0,0,a,0,a,a,a,0,0,0,0,0),
c(0,0,0,0,0,a,a,0,a,a,0,0,0,0,0),
c(0,0,0,0,0,a,a,a,0,a,0,0,0,0,0),
c(0,0,0,0,0,0,a,a,a,0,a,0,0,0,0),
c(0,0,0,0,0,0,0,0,0,a,0,a,a,a,0),
c(0,0,0,0,0,0,0,0,0,0,a,0,a,a,a),
c(0,0,0,0,0,0,0,0,0,0,a,a,0,a,a),
c(0,0,0,0,0,0,0,0,0,0,a,a,a,0,a),
c(a,0,0,0,0,0,0,0,0,0,0,a,a,a,0))
get.opt.choice(1, 3, 5, 12, tMat, 1, 1)
get.opt.choice(1, 15, 5, 12, tMat, 1, 1)
get.opt.choice(1, 15, 5, 2, tMat, 1, 1)
get.opt.choice(1, 15, 5, 2, tMat, 1, -1)
get.opt.choice(1, 4, 5, 2, tMat, 1, -1)
get.opt.choice(1, 4, 5, 3, tMat, 1, -1)
get.opt.choice(1, 4, 5, 4, tMat, 1, -1)
################################################################################
############################ Schapiro - Bet tests ##############################
################################################################################
library(data.table)
library(foreach)
library(doParallel)
library(matrixcalc)
################################################################################
# Task Parameters
nTrs <- 100
winM <- 1
nVisit <- 15
# Transitions in list and in matrix form
Edges <- list(c(02,03,04,15),
c(01,03,04,05),
c(01,02,04,05),
c(01,02,03,05),
c(02,03,04,06),
c(05,07,08,09),
c(06,08,09,10),
c(06,07,09,10),
c(06,07,08,10),
c(07,08,09,11),
c(10,12,13,14),
c(11,13,14,15),
c(11,12,14,15),
c(11,12,13,15),
c(12,13,14,01))
a <- 0.25
tMat <- rbind(c(0,a,a,a,0,0,0,0,0,0,0,0,0,0,a),
c(a,0,a,a,a,0,0,0,0,0,0,0,0,0,0),
c(a,a,0,a,a,0,0,0,0,0,0,0,0,0,0),
c(a,a,a,0,a,0,0,0,0,0,0,0,0,0,0),
c(0,a,a,a,0,a,0,0,0,0,0,0,0,0,0),
c(0,0,0,0,a,0,a,a,a,0,0,0,0,0,0),
c(0,0,0,0,0,a,0,a,a,a,0,0,0,0,0),
c(0,0,0,0,0,a,a,0,a,a,0,0,0,0,0),
c(0,0,0,0,0,a,a,a,0,a,0,0,0,0,0),
c(0,0,0,0,0,0,a,a,a,0,a,0,0,0,0),
c(0,0,0,0,0,0,0,0,0,a,0,a,a,a,0),
c(0,0,0,0,0,0,0,0,0,0,a,0,a,a,a),
c(0,0,0,0,0,0,0,0,0,0,a,a,0,a,a),
c(0,0,0,0,0,0,0,0,0,0,a,a,a,0,a),
c(a,0,0,0,0,0,0,0,0,0,0,a,a,a,0))
################################################################################
# Symmetry assistance
idmap.d  <- list(a=c(2,3,4),b=c(7,8,9),c=c(12,13,14))    # All deep nodes
idmap.bt <- list(a=c(1,5), b=c(6,10), c=c(11,15))        # All bottleneck nodes
c.map <- list(a=c('c','b'), b=c('a','c'), c=c('b','a'))  # Cluster maps of bottlenecks
idmap.dg  <- list(a=c(1,15), b=c(2,3,4, 12,13,14), c=c(5,11), d=c(6,10), e=c(8,9)) # Symmetries to Deep Goal (b) ; goal = 7
idmap.bg  <- list(a=c(1), b=c(2,3,4), c=c(5), d=c(7,8,9), e=c(10), f=c(11),g=c(12,13,14),h=c(15)) # Symmetries to Bottleneck Goal (b) ; goal = 6
################################################################################
# Analysis of goal reaches and expected values #
## Goal Hits per start & goal type & stepsleft ----
# Organize different start and goal types
s.types <- c('deep','bottleneck')
g.types <- c('deep','bottleneck close', 'bottleneck far')
# Which trial (node presentation) is the goal reached?
TrReach = 2:15
# Initialize data.table to get all values
Analytics <- data.table(rbind(expand.grid(s.types[1], g.types, NA, TrReach),
expand.grid(s.types[2], g.types, c('close','far'), TrReach)))
names(Analytics) <- c('s.type', 'g.type', 'clust.loc', 't.reach')
Analytics$goalp  <- 0
Analytics$startp <- 0
Analytics$reachp <- 0
# Create representative starting and goal nodes for analysis
start.v <- list('deep'       = c(0,1,0,0,0,0,0,0,0,0,0,0,0,0,0),
'bottleneck' = c(0,0,0,0,1,0,0,0,0,0,0,0,0,0,0))
#goal.v  <- list('deep' = c(7,6,10), 'bottleneck' = c(7,12,6,10,15,11))
goal.v <- list('deep' = c(7,6,10), 'bottleneck' = list('close'=c(7,6,10), 'far'=c(12,15,11)))
# Fill the Analytics matrix with the values
for(i in 1:nrow(Analytics)){
# Get start/goal type
st <- Analytics[i,s.type]
gl <- Analytics[i,g.type]
# Get actual nodes
st.v <- start.v[[st]] #Vector form
if(st=='deep'){gl.v <- goal.v[[st]][which(g.types==gl)]
}else if(st=='bottleneck'){gl.v <- goal.v[[st]][[Analytics[i,clust.loc]]][which(g.types==gl)]}
# Get absorbing transition matrix
tMat.abs <- tMat
tMat.abs[gl.v,] <- 0
# Get chance of reaching the goal at EXACTLY node nr t.reach
Analytics$reachp[i] <- (st.v %*% matrix.power(tMat.abs, Analytics[i, t.reach-1]))[gl.v]
# Get chances of having sampled this start/goal type
if(st=='deep'){
Analytics$startp[i] <- 3/5
if(gl=='deep'){
Analytics$goalp[i] <- 3/5
}else{
Analytics$goalp[i] <- 1/5
}
}else if(st=='bottleneck'){
Analytics$startp[i] <- 2/5
if(grepl('deep',gl,fixed=T)){
Analytics$goalp[i] <- 3/10
}else{
Analytics$goalp[i] <- 1/10
}
}
}
## Attach an overall trajectory chance of occurrence ----
Analytics[,trajp:=goalp*startp*reachp, by=.(s.type,g.type,t.reach)]
# Overall goal hit rate!
Analytics[,sum(trajp)] * nTrs
## Trial types of start-goal combinations and number of expected wins
trTypes <- Analytics[,list(startp=unique(startp),goalp=unique(goalp),clust.loc=unique(clust.loc), trajp=sum(trajp)), by=.(s.type,g.type,clust.loc)
][,list(nTrs=startp*goalp*nTrs, nWin=nTrs*trajp), by=.(s.type,g.type,clust.loc)
][,list(nTrs, nWin=floor(nWin),resWin=nWin-floor(nWin)), by=.(s.type,g.type,clust.loc)
][s.type=='deep'&g.type=='deep'|s.type=='bottleneck'&g.type=='bottleneck far' & clust.loc=='far'|s.type=='deep'&g.type=='bottleneck far'
|s.type=='bottleneck'&g.type=='deep'&clust.loc=='far'|s.type=='deep'&g.type=='bottleneck close', nWin:=nWin+1
][,list(s.type,g.type,clust.loc,nTrs,nWin,nLose=nTrs-nWin)
][c(5,6,8,9,4,7,2,3,1)]
## Get the expected number of steps FOR WINNING trials, per start-goal combination type ----
(merge(trTypes, Analytics[,sum(reachp/sum(reachp)*(t.reach-1)), by=.(s.type,g.type,clust.loc)])[,list(s.type,g.type,clust.loc,sum.winstep = V1*nWin)
][,sum(sum.winstep)] + (71*14)) / (15*4)
################################################################################
## Expected value by win multiplier ----
# Get ids for different goals
goal.vs <- c(7,6)
EV.anal <- data.table(start.v=0, goal.v=0, stepsleft=0, EV=0, pol.type='none', sym.id='z')
for(i in 1:2){
symlist <- list(idmap.dg, idmap.bg)[[i]] # Get appropriate symmetry iDs
goal.v <- goal.vs[i] # Set relevant goal
pol.type <- c('deep', 'bottleneck')[i]
# Absorbing transition matrix
tMat.abs <- tMat
tMat.abs[goal.v,] <- 0
for(j in 1:length(symlist)){
cur.v <- symlist[[j]][1] # Extract an exemplar node from symmetry
sym.id <- names(symlist)[j]
stateVec <- rep(0,15)    # Into vector representation
stateVec[cur.v] <- 1
hitC <- rep(0, 14)
for(s in 14:1){
hitC[s] <- (stateVec %*% matrix.power(tMat.abs, s))[goal.v]
}
relEV <- cumsum(hitC) * winM + (1-cumsum(hitC)) * -1
EV.anal <- rbind(EV.anal, data.table(start.v=cur.v, goal.v=goal.v, stepsleft=1:14, EV=relEV, pol.type=pol.type, sym.id=sym.id))
}
}
EV.anal <- EV.anal[-1,]
EV.anal$goal.v <- as.factor(EV.anal$goal.v)
EV.anal$start.v <- as.factor(EV.anal$start.v)
ggplot(EV.anal, aes(x=stepsleft, y=EV, col=start.v)) +
geom_line() +
geom_hline(yintercept=0, col='red') +
facet_grid(.~goal.v) +
scale_color_manual(values = c("#2c83bb", "#bf3a2b", "#22b061", "#929e9d", "#101110","#101110","#929e9d","#9eddbb","#929e9d","#845d8d"))
library(ggplot2)
ggplot(EV.anal, aes(x=stepsleft, y=EV, col=start.v)) +
geom_line() +
geom_hline(yintercept=0, col='red') +
facet_grid(.~goal.v) +
scale_color_manual(values = c("#2c83bb", "#bf3a2b", "#22b061", "#929e9d", "#101110","#101110","#929e9d","#9eddbb","#929e9d","#845d8d"))
get.opt.choice(1, 3, 4, 4, tMat, 1, -1)
get.opt.choice(1, 3, 4, 3, tMat, 1, -1)
get.opt.choice(1, 3, 4, 2, tMat, 1, -1)
################################################################################
####### Get data from devtest ArtDealer and plot a little bit the choices ######
################################################################################
# Load from SQL (laptop local)
library(RMySQL)
dbConnection <- dbConnect(MySQL(), host="mysql.ugent.be", user="s240338", password="PCGbU2wp@-wEGt6E", dbname="lccl")
data <- dbReadTable(dbConnection,"`ArtDealer_testdev_data`")
#################################################################################
## Wrangle database retrieved data into neat data.table
library(data.table)
library(ggplot2)
# Put database into table
devtest01 <- as.data.table(data)
# All randID participants into numbers
devtest01$randID <- as.factor(devtest01$randID)
levels(devtest01$randID) <- c(1:length(levels(devtest01$randID)))
# Save only interesting participants and entries
fullpp <- devtest01[randID %in% c(1) & !is.na(node) & !is.na(decision) & miniblock>=0,
.(randID, miniblock, nSteps, node, decision, rt, trBet, totRew)]
# Identify nodes as deep or bottleneck
fullpp[,nodeType := if(node%in%c(0,4,5,9,10,14)){'btn'}else{'deep'},by=.(randID,miniblock,nSteps)]
# Define starting transitions
fullpp[nSteps==0, transType:='start']
# Define bottleneck transitions between clusters
fullpp[nSteps!=0 & nodeType=='btn' & shift(nodeType, n=1, type='lag')=='btn', transType:='between']
# Define all transitions that stay within one cluster
fullpp[is.na(transType), transType:='within']
#################################################################################
## Analyze RT difference of within and between transitions
fullpp$rt <- as.integer(fullpp$rt)
ggplot(fullpp[transType!='start' & decision %in% c('down','up'),], aes(x=rt, col=interaction(transType)))+
geom_density() +
geom_vline(data=fullpp[transType!='start' & decision %in% c('down','up'),mean(rt),by=.(transType,decision)],
aes(xintercept=V1), color=c('blue', 'red','blue','red'))+
facet_grid(rows=vars(decision))
#################################################################################
## Analyze proportion of normative choices
library(matrixcalc)
a <- 0.25
tMat <- rbind(c(0,a,a,a,0,0,0,0,0,0,0,0,0,0,a),
c(a,0,a,a,a,0,0,0,0,0,0,0,0,0,0),
c(a,a,0,a,a,0,0,0,0,0,0,0,0,0,0),
c(a,a,a,0,a,0,0,0,0,0,0,0,0,0,0),
c(0,a,a,a,0,a,0,0,0,0,0,0,0,0,0),
c(0,0,0,0,a,0,a,a,a,0,0,0,0,0,0),
c(0,0,0,0,0,a,0,a,a,a,0,0,0,0,0),
c(0,0,0,0,0,a,a,0,a,a,0,0,0,0,0),
c(0,0,0,0,0,a,a,a,0,a,0,0,0,0,0),
c(0,0,0,0,0,0,a,a,a,0,a,0,0,0,0),
c(0,0,0,0,0,0,0,0,0,a,0,a,a,a,0),
c(0,0,0,0,0,0,0,0,0,0,a,0,a,a,a),
c(0,0,0,0,0,0,0,0,0,0,a,a,0,a,a),
c(0,0,0,0,0,0,0,0,0,0,a,a,a,0,a),
c(a,0,0,0,0,0,0,0,0,0,0,a,a,a,0))
fullpp
get.opt.choice(1, 3, 4, 0, tMat, 1, -1)
# Function that calculates optimal choices for Schapiro-Bet task
get.opt.choice <- function(tr, v, goal, stepsleft, tMat, winM, loseM){
opt.EV <- rep(0, length(v))
for(toti in 1:length(v)){
I <- rep(0,15); I[v[toti]]<-1
if(stepsleft[toti]==0|v[toti]==goal[toti]){
if(v[toti]==goal[toti]){opt.EV[toti]<-winM}else{opt.EV[toti]<-loseM}
}else{
hitVec <- rep(0,15)
tMat.goal <- tMat
tMat.goal[goal[toti],] <- 0
for(s in stepsleft[toti]:1){
hitC <- I %*% matrix.power(tMat.goal, s)
hitVec[s] <- hitC[goal[toti]]
}
opt.EV[toti] <- sum(hitVec)*winM + (1-sum(hitVec)) * loseM
}
}
opt.choice <- as.numeric(opt.EV>0)
opt.choice[which(opt.choice==0)] <- -1
return(opt.choice)
}
get.opt.choice(1, 3, 4, 0, tMat, 1, -1)
fullpp
################################################################################
####### Get data from devtest ArtDealer and plot a little bit the choices ######
################################################################################
# Load from SQL (laptop local)
library(RMySQL)
dbConnection <- dbConnect(MySQL(), host="mysql.ugent.be", user="s240338", password="PCGbU2wp@-wEGt6E", dbname="lccl")
data <- dbReadTable(dbConnection,"`ArtDealer_testdev_data`")
#################################################################################
## Wrangle database retrieved data into neat data.table
library(data.table)
library(ggplot2)
# Put database into table
devtest01 <- as.data.table(data)
# All randID participants into numbers
devtest01$randID <- as.factor(devtest01$randID)
levels(devtest01$randID) <- c(1:length(levels(devtest01$randID)))
# Save only interesting participants and entries
fullpp <- devtest01[randID %in% c(1) & !is.na(node) & !is.na(decision) & miniblock>=0,
.(randID, miniblock, nSteps, node, decision, choiceVar, rt, trBet, totRew)]
# Identify nodes as deep or bottleneck
fullpp[,nodeType := if(node%in%c(0,4,5,9,10,14)){'btn'}else{'deep'},by=.(randID,miniblock,nSteps)]
# Define starting transitions
fullpp[nSteps==0, transType:='start']
# Define bottleneck transitions between clusters
fullpp[nSteps!=0 & nodeType=='btn' & shift(nodeType, n=1, type='lag')=='btn', transType:='between']
# Define all transitions that stay within one cluster
fullpp[is.na(transType), transType:='within']
#################################################################################
## Analyze RT difference of within and between transitions
fullpp$rt <- as.integer(fullpp$rt)
ggplot(fullpp[transType!='start' & decision %in% c('down','up'),], aes(x=rt, col=interaction(transType)))+
geom_density() +
geom_vline(data=fullpp[transType!='start' & decision %in% c('down','up'),mean(rt),by=.(transType,decision)],
aes(xintercept=V1), color=c('blue', 'red','blue','red'))+
facet_grid(rows=vars(decision))
fullpp
get.opt.choice(1, c(1,2,3,2,1,2,3), 4, 0, tMat, 1, -1)
# Function that calculates optimal choices for Schapiro-Bet task
get.opt.choice <- function(tr, v, goal, stepsleft, tMat, winM, loseM){
opt.EV <- rep(0, length(v))
for(toti in 1:length(v)){
I <- rep(0,15); I[v[toti]]<-1
if(stepsleft[toti]==0|v[toti]==goal[toti]){
if(v[toti]==goal[toti]){opt.EV[toti]<-winM}else{opt.EV[toti]<-loseM}
}else{
hitVec <- rep(0,15)
tMat.goal <- tMat
tMat.goal[goal[toti],] <- 0
for(s in stepsleft[toti]:1){
hitC <- I %*% matrix.power(tMat.goal, s)
hitVec[s] <- hitC[goal[toti]]
}
opt.EV[toti] <- sum(hitVec)*winM + (1-sum(hitVec)) * loseM
}
}
opt.choice <- as.numeric(opt.EV>0)
opt.choice[which(opt.choice==0)] <- -1
return(opt.choice)
}
get.opt.choice(1, c(1,2,3,2,1,2,3), 4, 0, tMat, 1, -1)
fullpp
# Save only interesting participants and entries
fullpp <- devtest01[randID %in% c(1) & !is.na(node) & !is.na(decision) & miniblock>=0,
.(randID, miniblock, nSteps, node, goalnode, decision, choiceVar, rt, trBet, totRew)]
# Identify nodes as deep or bottleneck
fullpp[,nodeType := if(node%in%c(0,4,5,9,10,14)){'btn'}else{'deep'},by=.(randID,miniblock,nSteps)]
# Define starting transitions
fullpp[nSteps==0, transType:='start']
# Define bottleneck transitions between clusters
fullpp[nSteps!=0 & nodeType=='btn' & shift(nodeType, n=1, type='lag')=='btn', transType:='between']
# Define all transitions that stay within one cluster
fullpp[is.na(transType), transType:='within']
#################################################################################
## Analyze RT difference of within and between transitions
fullpp$rt <- as.integer(fullpp$rt)
ggplot(fullpp[transType!='start' & decision %in% c('down','up'),], aes(x=rt, col=interaction(transType)))+
geom_density() +
geom_vline(data=fullpp[transType!='start' & decision %in% c('down','up'),mean(rt),by=.(transType,decision)],
aes(xintercept=V1), color=c('blue', 'red','blue','red'))+
facet_grid(rows=vars(decision))
fullpp
#################################################################################
## Analyze proportion of normative choices
library(matrixcalc)
a <- 0.25
tMat <- rbind(c(0,a,a,a,0,0,0,0,0,0,0,0,0,0,a),
c(a,0,a,a,a,0,0,0,0,0,0,0,0,0,0),
c(a,a,0,a,a,0,0,0,0,0,0,0,0,0,0),
c(a,a,a,0,a,0,0,0,0,0,0,0,0,0,0),
c(0,a,a,a,0,a,0,0,0,0,0,0,0,0,0),
c(0,0,0,0,a,0,a,a,a,0,0,0,0,0,0),
c(0,0,0,0,0,a,0,a,a,a,0,0,0,0,0),
c(0,0,0,0,0,a,a,0,a,a,0,0,0,0,0),
c(0,0,0,0,0,a,a,a,0,a,0,0,0,0,0),
c(0,0,0,0,0,0,a,a,a,0,a,0,0,0,0),
c(0,0,0,0,0,0,0,0,0,a,0,a,a,a,0),
c(0,0,0,0,0,0,0,0,0,0,a,0,a,a,a),
c(0,0,0,0,0,0,0,0,0,0,a,a,0,a,a),
c(0,0,0,0,0,0,0,0,0,0,a,a,a,0,a),
c(a,0,0,0,0,0,0,0,0,0,0,a,a,a,0))
get.opt.choice(1, c(1,2,3,2,1,2,3), 4, 0, tMat, 1, -1)
fullpp[,opt.choice:=get.opt.choice(miniblock+1, node, goalnode, 15-nSteps-1, tMat, 1, -1), by=.(randID,miniblock)]
fullpp$rt <- as.integer(fullpp$rt)
fullpp$nSteps <- as.integer(fullpp$nSteps)
fullpp$miniblock <- as.integer(fullpp$miniblock)
fullpp[,opt.choice:=get.opt.choice(miniblock+1, node, goalnode, (15-nSteps-1), tMat, 1, -1), by=.(randID,miniblock)]
fullpp$node <- as.integer(fullpp$node)
fullpp$goalnode <- as.integer(fullpp$goalnode)
fullpp[,opt.choice:=get.opt.choice(miniblock+1, node, goalnode, (15-nSteps-1), tMat, 1, -1), by=.(randID,miniblock)]
debug(get.opt.choice)
fullpp[,opt.choice:=get.opt.choice(miniblock+1, node, goalnode, (15-nSteps-1), tMat, 1, -1), by=.(randID,miniblock)]
tr
v
goal
stepsleft
tMat
winM
loseM
opt.EV
I
I
stepsleft
toti
v[toti]
v[toti]
goal[toti]
hietC
hitC
hitVec
fullpp[,opt.choice:=get.opt.choice(miniblock+1, node, goalnode, (15-nSteps-1), tMat, 1, -1), by=.(randID,miniblock)]
fullpp[,opt.choice:=get.opt.choice(miniblock+1, node, goalnode, (15-nSteps-1), tMat, 1, -1), by=.(randID,miniblock)]
opt.EV
hitVec
tMat.goal
hitC
fullpp[,opt.choice:=get.opt.choice(miniblock+1, node, goalnode, (15-nSteps-1), tMat, 1, -1), by=.(randID,miniblock)]
I
tMat.goal
fullpp[,opt.choice:=get.opt.choice(miniblock+1, node, goalnode, (15-nSteps-1), tMat, 1, -1), by=.(randID,miniblock)]
stepsleft[toti]
I %*% matrix.power(tMat.goal, 14)
fullpp$nSteps <- as.numeric(fullpp$nSteps)
fullpp[,opt.choice:=get.opt.choice(miniblock+1, node, goalnode, (15-nSteps-1), tMat, 1, -1), by=.(randID,miniblock)]
fullpp[,opt.choice:=get.opt.choice(miniblock+1, node, goalnode, (15-nSteps-1), tMat, 1, -1), by=.(randID,miniblock)]
fullpp[,opt.choice:=get.opt.choice(miniblock+1, node, goalnode, (15-nSteps-1), tMat, 1, -1), by=.(randID,miniblock)]
14L
matrix.power(tMat.goal, 14)
matrix.power(tMat.goal, 14L)
k
length(k)
x
class(x)
dim(x)
nrow()
nrow(x)
I
opt.EV
toti
opt.EV
v
goal
fullpp[,opt.choice:=get.opt.choice(miniblock+1, node+1, goalnode+1, (15-nSteps-1), tMat, 1, -1), by=.(randID,miniblock)]
undebug(get.opt.choice)
fullpp[,opt.choice:=get.opt.choice(miniblock+1, node+1, goalnode+1, (15-nSteps-1), tMat, 1, -1), by=.(randID,miniblock)]
fullpp
fullpp[miniblock==1]
fullpp[miniblock==2]
fullpp[miniblock==3]
fullpp[choiceVar==-1,]
fullpp[choiceVar==0,]
fullpp[choiceVar==1,]
fullpp[opt.choice==-1, opt.choice:=0]
fullpp
# Evaluate current choice as optimal or not
fullpp[,was.choice.opt:=choiceVar==opt.choice, by=.(randID, miniblock, nSteps)]
fullpp
0:99+1
(0:99+1)/10
ceil((0:99+1)/10)
ceiling((0:99+1)/10)
# Bin into groups of 10 miniblocks
fullpp[,opt.block.div:=(miniblock+1)/10,by=.(randID,miniblock,nSteps)]
fullpp
# Bin into groups of 10 miniblocks
fullpp[,opt.block.div:=ceiling((miniblock+1)/10),by=.(randID,miniblock,nSteps)]
fullpp
# Get percentage optimal choices per bin!
fullpp[,perc.opt:=sum(was.choice.opt),by-opt.block.div]
# Get percentage optimal choices per bin!
fullpp[,perc.opt:=sum(was.choice.opt),by=opt.block.div]
fullpp
# Get percentage optimal choices per bin!
fullpp[,sum(was.choice.opt)/.N,by=opt.block.div]
# Get percentage optimal choices per bin!
plot(1:10,fullpp[,sum(was.choice.opt)/.N,by=opt.block.div]$V1)
# Get percentage optimal choices per bin!
plot(1:10,fullpp[,sum(was.choice.opt)/.N,by=opt.block.div]$V1, type='l')
(1:100)/5
ceiling((1:100)/5)
# Bin into groups of 10 miniblocks
fullpp[,opt.block.div:=ceiling((miniblock+1)/5),by=.(randID,miniblock,nSteps)]
# Get percentage optimal choices per bin!
plot(1:20,fullpp[,sum(was.choice.opt)/.N,by=opt.block.div]$V1, type='l')
fullpp
fullpp[,list(percent.correct=sum(was.choice.opt)/.N),by=opt.block.div]
ggplot(fullpp[,list(percent.correct=sum(was.choice.opt)/.N),by=opt.block.div], aes(x=opt.block.div, y=percent.correct))+
geom_line()
#################################################################################
## Analyze RT difference of within and between transitions
ggplot(fullpp[transType!='start' & decision %in% c('down','up'),], aes(x=rt, col=transType))+
geom_density() +
geom_vline(data=fullpp[transType!='start' & decision %in% c('down','up'),mean(rt),by=.(transType,decision)],
aes(xintercept=V1), color=c('blue', 'red','blue','red'))+
facet_grid(rows=vars(decision))
