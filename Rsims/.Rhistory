geom_point()+
ylim(min(EVdat$value)-0.5, max(EVdat$value+0.5)) +
annotate(geom='segment', x=max(which(EVdat[EVdat$trans=='1<-5',]$value<0))+0.05,
xend=max(which(EVdat[EVdat$trans=='1<-5',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
yend=EVdat[EVdat$trans=='1<-5',]$value[max(which(EVdat[EVdat$trans=='1<-5',]$value<0))],
color=brewer.pal(n=8,name='Set3')[6]) +
annotate(geom='text',    x=max(which(EVdat[EVdat$trans=='1<-5',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
label=as.character(max(which(EVdat[EVdat$trans=='1<-5',]$value<0))),
color=brewer.pal(n=10,name='Set3')[6]) +
annotate(geom='segment', x=max(which(EVdat[EVdat$trans=='1<-2',]$value<0))+0.05,
xend=max(which(EVdat[EVdat$trans=='1<-2',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
yend=EVdat[EVdat$trans=='1<-2',]$value[max(which(EVdat[EVdat$trans=='1<-2',]$value<0))],
color=brewer.pal(n=10,name='Set3')[7]) +
annotate(geom='text',    x=max(which(EVdat[EVdat$trans=='1<-2',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
label=as.character(max(which(EVdat[EVdat$trans=='1<-2',]$value<0))),
color=brewer.pal(n=10,name='Set3')[7]) +
annotate(geom='segment', x=max(which(EVdat[EVdat$trans=='5<-15',]$value<0))+0.05,
xend=max(which(EVdat[EVdat$trans=='5<-15',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
yend=EVdat[EVdat$trans=='5<-15',]$value[max(which(EVdat[EVdat$trans=='5<-15',]$value<0))],
color=brewer.pal(n=10,name='Set3')[8]) +
annotate(geom='text',    x=max(which(EVdat[EVdat$trans=='5<-15',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
label=as.character(max(which(EVdat[EVdat$trans=='5<-15',]$value<0))),
color=brewer.pal(n=10,name='Set3')[8]) +
annotate(geom='segment', x=max(which(EVdat[EVdat$trans=='5<-1',]$value<0))+0.05,
xend=max(which(EVdat[EVdat$trans=='5<-1',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
yend=EVdat[EVdat$trans=='5<-1',]$value[max(which(EVdat[EVdat$trans=='5<-1',]$value<0))],
color=brewer.pal(n=10,name='Set3')[9]) +
annotate(geom='text',    x=max(which(EVdat[EVdat$trans=='5<-1',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
label=as.character(max(which(EVdat[EVdat$trans=='5<-1',]$value<0))),
color=brewer.pal(n=10,name='Set3')[9]) +
annotate(geom='segment', x=max(which(EVdat[EVdat$trans=='1<-4',]$value<0))+0.05,
xend=max(which(EVdat[EVdat$trans=='1<-4',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
yend=EVdat[EVdat$trans=='1<-4',]$value[max(which(EVdat[EVdat$trans=='1<-4',]$value<0))],
color=brewer.pal(n=10,name='Set3')[10]) +
annotate(geom='text',    x=max(which(EVdat[EVdat$trans=='1<-4',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
label=as.character(max(which(EVdat[EVdat$trans=='1<-4',]$value<0))),
color=brewer.pal(n=10,name='Set3')[10]) +
geom_hline(yintercept=0, color='red') +
scale_color_brewer(palette='Set3')+
theme_dark()
}
EVplot(EV_data)
############################################################################################################################
################################# Analysis of Modular Graph with costs and rewards #########################################
############################################################################################################################
library(ggplot2)
EVplot(EV_data)
library(ggthemes)
library(RColorBrewer)
library(ggstance)
library(lemon)
EVplot(EV_data)
EV_data
levels(EV_data$trans)
load("C:/Users/wient/OneDrive - UGent/Projects/ModularGraphs-RL/Rsims/data/MC_Rew_noBT_data.RData")
AG.dat.ppEval
ggplot(AG.dat.ppEval, aes(x=totRew, col=strat)) +
geom_density() +
facet_grid(reward~cost)
############################################################################################################################
################################# Analysis of Modular Graph with costs and rewards #########################################
############################################################################################################################
library(ggplot2)
library(reshape2)
library(ggthemes)
library(RColorBrewer)
library(ggstance)
library(lemon)
ggplot(AG.dat.ppEval, aes(x=totRew, col=strat)) +
geom_density() +
facet_grid(reward~cost)
# Starting node and goal (rewarded) termination node
vStart <- 1
vGoal  <- 8
# Full edges matrix (schapiro-style random walk)
Edges <- list(c(2, 3, 4, 5),
c(1, 3, 4, 5),
c(1, 2, 4, 5),
c(1, 2, 3, 6),
c(1, 2, 3, 15),
c(4, 7, 8, 9),
c(6, 8, 9, 10),
c(6, 7, 9, 10),
c(6, 7, 8, 10),
c(11,7, 8, 9),
c(10,12,13,14),
c(11,13,14,15),
c(11,12,14,15),
c(11,12,13,15),
c(5, 12,13,14))
# Which transitions do we want to evaluate on value
inspect.Edges <- rbind(c(1,2),
c(1,4),
c(1,5),
c(4,1),
c(4,6),
c(5,1),
c(5,15),
c(6,4),
c(6,7),
c(7,6),
c(7,9))
hitMat.nBT  <- read.csv('data/no-BT_step-9_hit_unique.csv',row.names=1,check.names=F)
## Precalc goalstepchange ----
# Get starting expectations
propStart <- rep(0,length(1:11))
for(nV in 1:11){
paths   <- 0
queue   <- list(c(0,1))
while(length(queue) > 0){
pCur <- queue[[1]]
for(t in Edges[[tail(pCur,1)]]){
if(t!= tail(pCur,2)[1] & length(c(pCur,t))<(nV+1)){         #No-backtrack
#if(length(c(pCur,t))<nV){                              #Backtrack
queue <- append(queue,list(c(pCur,t)))
}else if(t!= tail(pCur,2)[1] & length(c(pCur,t))==(nV+1)){  #No-backtrack
#}else if(length(c(pCur,t))==nV){                       #Backtrack
paths <- paths+1
if(vGoal == t & !vGoal %in% pCur){
propStart[nV] <- propStart[nV]+1
}
}
}
queue[[1]] <- NULL
}
}
propStart <- propStart[-1]
goalstepchance <- rep(0,10)
for(nSteps in 1:10){
goalstepchance[nSteps] <- propStart[nSteps]/(4*3^(nSteps-1))
}
############################################################################################################################
## Plot the EVs over different transitions for different steps ----
EV_data <- EVcalc(Edges = Edges, vStart=vStart, vGoal=vGoal, nSteps=10, gRew=7, sCost=0.15, hitMat=hitMat.nBT, goalstepchance=goalstepchance)
# Function that ouptputs a Data Frame of expected values per state-step conjunction
EVcalc <- function(Edges, vStart, vGoal, nSteps, gRew, sCost, hitMat=F, goalstepchance=F, inspect.Edges=F){
# Brute-force a full HitMat if not provided (add later)
if(!class(hitMat) %in% c( 'matrix', 'data.frame')){
stop('You have not provided a hit-matrix. Currently the flexible calculation of a hit-matrix is not supported by this function.')
}
# Brute-force the chances of hitting from the starting position if not provided (for now dependent on Schapiro)
if(class(goalstepchance) != 'numeric'){
print('No information is provided about goal-attainment from starting position. Calculated using Schapiro-style layout.')
# Get starting expectations
propStart <- rep(0,length(1:(nSteps+1)))
for(nV in 1:(nSteps+1)){
paths   <- 0
queue   <- list(c(0,1))
while(length(queue) > 0){
pCur <- queue[[1]]
for(t in Edges[[tail(pCur,1)]]){
if(t!= tail(pCur,2)[1] & length(c(pCur,t))<(nV+1)){         #No-backtrack
#if(length(c(pCur,t))<nV){                              #Backtrack
queue <- append(queue,list(c(pCur,t)))
}else if(t!= tail(pCur,2)[1] & length(c(pCur,t))==(nV+1)){  #No-backtrack
#}else if(length(c(pCur,t))==nV){                       #Backtrack
paths <- paths+1
if(vGoal == t & !vGoal %in% pCur){
propStart[nV] <- propStart[nV]+1
}
}
}
queue[[1]] <- NULL
}
}
propStart <- propStart[-1]
goalstepchance <- rep(0,10)
for(nSteps in 1:nSteps){
goalstepchance[nSteps] <- propStart[nSteps]/(4*3^(nSteps-1))
}
}
# Check if we know relevant edges to inspect
if(inspect.Edges==F & !class(hitMat) %in% c('matrix','data.frame')){
stop('You must either provide a hit-matrix containing the edges you wish to inspect as row names, or a list of Edges you wish to inspect.')
}
# Check if edges are legal in provided graph (edge list)
EVmat <- matrix(nrow=nrow(hitMat.nBT), ncol=ncol(hitMat.nBT))
rownames(EVmat) <- rownames(hitMat.nBT)
colnames(EVmat) <- colnames(hitMat.nBT)
for(leftSteps in 1:ncol(hitMat.nBT)){
for(transid in rownames(hitMat.nBT)){
intRew <- 0
goalProb.s <- rep(0,leftSteps)
for(s in 1:leftSteps){
goalProb.s[s] <- hitMat.nBT[transid,s]/(3^s)
intRew <- intRew + goalProb.s[s] * (gRew-(sCost*s))
}
EV <- intRew - (1-sum(goalProb.s))*sCost*leftSteps
EVmat[transid,leftSteps] <- EV
}
}
EVdat <- melt(EVmat, varnames=c('trans','sLeft'))
EVdat <- rbind(EVdat, data.frame(trans='1<-|',sLeft=10,value=sum(goalstepchance * (gRew-(c(1:10)*sCost))) - ((1-sum(goalstepchance))*(10*sCost))))
EVdat$trans <- factor(EVdat$trans, levels=c(as.character(EVdat[EVdat$sLeft==9,][order(-EVdat[EVdat$sLeft==9,]$value),]$trans),'1<-|'), ordered=T)
return(EVdat)
}
# Function that plots the EVdat with the first crossing to EV-0 highlighted
EVplot <- function(EVdat){
ggplot(EVdat, aes(x=sLeft, y=value, color=trans)) +
geom_line(aes(group=trans)) +
geom_point()+
ylim(min(EVdat$value)-0.5, max(EVdat$value+0.5)) +
annotate(geom='segment', x=max(which(EVdat[EVdat$trans=='1<-5',]$value<0))+0.05,
xend=max(which(EVdat[EVdat$trans=='1<-5',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
yend=EVdat[EVdat$trans=='1<-5',]$value[max(which(EVdat[EVdat$trans=='1<-5',]$value<0))],
color=brewer.pal(n=8,name='Set3')[6]) +
annotate(geom='text',    x=max(which(EVdat[EVdat$trans=='1<-5',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
label=as.character(max(which(EVdat[EVdat$trans=='1<-5',]$value<0))),
color=brewer.pal(n=10,name='Set3')[6]) +
annotate(geom='segment', x=max(which(EVdat[EVdat$trans=='1<-2',]$value<0))+0.05,
xend=max(which(EVdat[EVdat$trans=='1<-2',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
yend=EVdat[EVdat$trans=='1<-2',]$value[max(which(EVdat[EVdat$trans=='1<-2',]$value<0))],
color=brewer.pal(n=10,name='Set3')[7]) +
annotate(geom='text',    x=max(which(EVdat[EVdat$trans=='1<-2',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
label=as.character(max(which(EVdat[EVdat$trans=='1<-2',]$value<0))),
color=brewer.pal(n=10,name='Set3')[7]) +
annotate(geom='segment', x=max(which(EVdat[EVdat$trans=='5<-15',]$value<0))+0.05,
xend=max(which(EVdat[EVdat$trans=='5<-15',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
yend=EVdat[EVdat$trans=='5<-15',]$value[max(which(EVdat[EVdat$trans=='5<-15',]$value<0))],
color=brewer.pal(n=10,name='Set3')[8]) +
annotate(geom='text',    x=max(which(EVdat[EVdat$trans=='5<-15',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
label=as.character(max(which(EVdat[EVdat$trans=='5<-15',]$value<0))),
color=brewer.pal(n=10,name='Set3')[8]) +
annotate(geom='segment', x=max(which(EVdat[EVdat$trans=='5<-1',]$value<0))+0.05,
xend=max(which(EVdat[EVdat$trans=='5<-1',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
yend=EVdat[EVdat$trans=='5<-1',]$value[max(which(EVdat[EVdat$trans=='5<-1',]$value<0))],
color=brewer.pal(n=10,name='Set3')[9]) +
annotate(geom='text',    x=max(which(EVdat[EVdat$trans=='5<-1',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
label=as.character(max(which(EVdat[EVdat$trans=='5<-1',]$value<0))),
color=brewer.pal(n=10,name='Set3')[9]) +
annotate(geom='segment', x=max(which(EVdat[EVdat$trans=='1<-4',]$value<0))+0.05,
xend=max(which(EVdat[EVdat$trans=='1<-4',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
yend=EVdat[EVdat$trans=='1<-4',]$value[max(which(EVdat[EVdat$trans=='1<-4',]$value<0))],
color=brewer.pal(n=10,name='Set3')[10]) +
annotate(geom='text',    x=max(which(EVdat[EVdat$trans=='1<-4',]$value<0))+0.05,
y=min(EVdat$value)-0.5,
label=as.character(max(which(EVdat[EVdat$trans=='1<-4',]$value<0))),
color=brewer.pal(n=10,name='Set3')[10]) +
geom_hline(yintercept=0, color='red') +
scale_color_brewer(palette='Set3')+
theme_dark()
}
############################################################################################################################
## Plot the EVs over different transitions for different steps ----
EV_data <- EVcalc(Edges = Edges, vStart=vStart, vGoal=vGoal, nSteps=10, gRew=7, sCost=0.15, hitMat=hitMat.nBT, goalstepchance=goalstepchance)
EVplot(EV_data)
############################################################################################################################
## Plot the EVs over different transitions for different steps ----
EV_data <- EVcalc(Edges = Edges, vStart=vStart, vGoal=vGoal, nSteps=10, gRew=8, sCost=0.3, hitMat=hitMat.nBT, goalstepchance=goalstepchance)
EVplot(EV_data)
Sys.time()
prev <- Sys.time()
prev - Sys.time()
prev - Sys.time()
remove(prev)
vStart <- 1
vGoal  <- 8
# Full edges matrix (schapiro-style random walk)
Edges <- list(c(2, 3, 4, 5),
c(1, 3, 4, 5),
c(1, 2, 4, 5),
c(1, 2, 3, 6),
c(1, 2, 3, 15),
c(4, 7, 8, 9),
c(6, 8, 9, 10),
c(6, 7, 9, 10),
c(6, 7, 8, 10),
c(11,7, 8, 9),
c(10,12,13,14),
c(11,13,14,15),
c(11,12,14,15),
c(11,12,13,15),
c(5, 12,13,14))
nVisit <- 10 #one more than the number of transitions (the first state counts, but is not transitioned into)
# Calculate nr of 'hits' in nSteps of complete random walk ----
paths   <- list()
queue   <- list(vStart)
pathIdx <- 1
hits <- 0
while(length(queue) > 0){
pCur <- queue[[1]]
if(length(pCur)==nVisit){
paths[[pathIdx]] <- pCur
pathIdx <- pathIdx+1
}else{
for(t in Edges[[tail(pCur,1)]]){
if(t==vGoal){
paths[[pathIdx]] <- c(pCur,t)
pathIdx <- pathIdx+1
hits <- hits+1
}else{
queue <- append(queue,list(c(pCur,t)))
}
}
}
queue[[1]] <- NULL
}
Edges[[1]]
sample(Edges[[1]],1)
sample(Edges[[1]],1)
sample(Edges[[1]],1)
sample(Edges[[1]],1)
sample(Edges[[1]],1)
sample(Edges[[1]],1)
sample(Edges[[1]],1)
sample(Edges[[1]],1)
sample(Edges[[1]],1)
tail(c(1,2,3,4),1)
MC.hitmat <- function(Edges, vStart, vGoal, nSteps, nSamp){
hitMat <- data.frame(goal='init', nSteps=0)
for(r in 1:nSamp){
path <- c(vStart)
while(length(path) < (nSteps+1)){
path <- c(path, sample(Edges[[tail(path,1)]]))
if(tail(path,1)==vGoal){
hitMat <- rbind(hitMat, data.frame(goal='yes', nSteps=(length(path)-1)))
break
}
}
}
}
debug(MC.hitmat)
MC.hitmat(Edges, vStart, vGoal, 10, 10)
hitMat
path
path
MC.hitmat <- function(Edges, vStart, vGoal, nSteps, nSamp){
hitMat <- data.frame(goal='init', nSteps=0)
for(r in 1:nSamp){
path <- c(vStart)
while(length(path) < (nSteps+1)){
path <- c(path, sample(Edges[[tail(path,1)]], 1))
if(tail(path,1)==vGoal){
hitMat <- rbind(hitMat, data.frame(goal='yes', nSteps=(length(path)-1)))
break
}
}
}
}
debug(MC.hitmat)
MC.hitmat(Edges, vStart, vGoal, 10)
MC.hitmat(Edges, vStart, vGoal, 10, 10)
path
path
path
path
path
path
path
path
path
path
path
MC.hitmat <- function(Edges, vStart, vGoal, nSteps, nSamp){
hitMat <- data.frame(goal='init', nSteps=0)
for(r in 1:nSamp){
path <- c(vStart)
while(length(path) < (nSteps+1)){
path <- c(path, sample(Edges[[tail(path,1)]], 1))
if(tail(path,1)==vGoal){
hitMat <- rbind(hitMat, data.frame(goal='yes', nSteps=(length(path)-1)))
break
}
}
hitMat <- rbind(hitMat, data.frame(goal='no', nSteps=(length(path)-1)))
}
}
debug(MC.hitmat)
MC.hitmat(Edges, vStart, vGoal, 10, 10)
path
path
path
path
path
path
length(path)
hitMat
MC.hitmat <- function(Edges, vStart, vGoal, nSteps, nSamp){
hitMat <- data.frame(goal='init', nSteps=0)
for(r in 1:nSamp){
path <- c(vStart)
while(length(path) < (nSteps+1)){
path <- c(path, sample(Edges[[tail(path,1)]], 1))
if(tail(path,1)==vGoal){
hitMat <- rbind(hitMat, data.frame(goal='yes', nSteps=(length(path)-1)))
break
}else if(length(path)==(nSteps+1)){
hitMat <- rbind(hitMat, data.frame(goal='no', nSteps=(length(path)-1)))
}
}
}
}
MC.hitmat(Edges, vStart, vGoal, 10, 10)
debug(MC.hitmat)
MC.hitmat(Edges, vStart, vGoal, 10, 10)
path
path
path
path
length(path)
hitMat
path
path
path
path
path
path
path
path
path
path]
path
path
path
path
path
path
path
path
length(path)
path
path
path
path
path
path
path
MC.hitmat <- function(Edges, vStart, vGoal, nSteps, nSamp){
hitMat <- data.frame(goal='init', nSteps=0)
for(r in 1:nSamp){
path <- c(vStart)
while(length(path) < (nSteps+1)){
path <- c(path, sample(Edges[[tail(path,1)]], 1))
if(tail(path,1)==vGoal){
hitMat <- rbind(hitMat, data.frame(goal='yes', nSteps=(length(path)-1)))
break
}else if(length(path)==(nSteps+1)){
hitMat <- rbind(hitMat, data.frame(goal='no', nSteps=(length(path)-1)))
}
}
}
return(hitMat)
}
MC.hitmat(Edges, vStart, vGoal, 10, 10)
MC.hitmat(Edges, vStart, vGoal, 10, 100)
#Do it with MC
MC.hitdat <- MC.hitmat(Edges, vStart, vGoal, nSteps=10, nSamp=100)
sum(MC.hitdat$goal=='yes')
sum(MC.hitdat$goal=='yes')/nrow(MC.hitdat)
#Do it with MC
MC.hitdat <- MC.hitmat(Edges, vStart, vGoal, nSteps=10, nSamp=1000)
sum(MC.hitdat$goal=='yes')/nrow(MC.hitdat)
#Do it with MC
MC.hitdat <- MC.hitmat(Edges, vStart, vGoal, nSteps=10, nSamp=1000)
sum(MC.hitdat$goal=='yes')/nrow(MC.hitdat)
#Do it with MC
MC.hitdat <- MC.hitmat(Edges, vStart, vGoal, nSteps=10, nSamp=1000)
sum(MC.hitdat$goal=='yes')/nrow(MC.hitdat)
#Do it with MC
MC.hitdat <- MC.hitmat(Edges, vStart, vGoal, nSteps=10, nSamp=10000)
sum(MC.hitdat$goal=='yes')/nrow(MC.hitdat)
#Do it with MC
MC.hitdat <- MC.hitmat(Edges, vStart, vGoal, nSteps=10, nSamp=10000)
sum(MC.hitdat$goal=='yes')/nrow(MC.hitdat)
#Do it with MC
MC.hitdat <- MC.hitmat(Edges, vStart, vGoal, nSteps=11, nSamp=10000)
sum(MC.hitdat$goal=='yes')/nrow(MC.hitdat)
#Do it with MC
MC.hitdat <- MC.hitmat(Edges, vStart, vGoal, nSteps=10, nSamp=1000)
sum(MC.hitdat$goal=='yes')/nrow(MC.hitdat)
#Do it with MC
MC.hitdat <- MC.hitmat(Edges, vStart, vGoal, nSteps=10, nSamp=10000)
sum(MC.hitdat$goal=='yes')/nrow(MC.hitdat)
#Do it with MC
testProp <- c()
testProp
testProp <- c(testProp, 1)
testProt
testProp
#Do it with MC
testProp <- c()
for(i in 1:100){
MC.hitdat <- MC.hitmat(Edges, vStart, vGoal, nSteps=10, nSamp=10000)
testProp <- c(testProp, sum(MC.hitdat$goal=='yes')/nrow(MC.hitdat))
}
testProp
plot(density(testProp))
MC.hitdat <- MC.hitmat(Edges, vStart, vGoal, nSteps=11, nSamp=10000)
sum(MC.hitdat$goal=='yes')/nrow(MC.hitdat)
MC.hitdat <- MC.hitmat(Edges, vStart, vGoal, nSteps=15, nSamp=10000)
sum(MC.hitdat$goal=='yes')/nrow(MC.hitdat)
MC.hitdat <- MC.hitmat(Edges, vStart, vGoal, nSteps=15, nSamp=10000)
sum(MC.hitdat$goal=='yes')/nrow(MC.hitdat)
