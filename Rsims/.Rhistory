queue[[1]] <- NULL
}
hitMat$goalprob <- hitMat$goalprob / totP
return(hitMat)
}
hitMat.calc.nBT(Edges, vGoal, 9, 1,2,3^9)
hitMat.calc.nBT <- function(Edges, vGoal, nSteps, curV, preV, totP){
# nSteps here identifies the total steps present in the sequence
#   The first step from preV -> curV is counted as well!
hitMat <- data.frame(preVertex = preV, Vertex = curV, steps = 1:nSteps, goalprob = 0)
queue <- list(c(preV,curV))
while(length(queue)>0){
pCur <- queue[[1]]
if(length(pCur) == nSteps & vGoal %in% Edges[[tail(pCur,1)]]){
hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==length(pCur),]$goalprob <- hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==length(pCur),]$goalprob + 3^( nSteps - length(pCur) )
}else if(length(pCur) < nSteps){
for(t in Edges[[tail(pCur,1)]][-which(Edges[[tail(pCur,1)]]==tail(pCur,2)[1])]){
if(t == vGoal){
hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==length(pCur),]$goalprob <- hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==length(pCur),]$goalprob + 3^( nSteps - length(pCur) )
}else{
queue <- append(queue, list(c(pCur,t)))
}
}
}
queue[[1]] <- NULL
}
hitMat$goalprob <- hitMat$goalprob / totP
return(hitMat)
}
hitMat.calc.nBT(Edges, vGoal, 9, 1,2,3^9)
3^9
700/3^9
244/3^9
1/3^9
hitMat.calc.nBT(Edges, vGoal, 9, 1,2,3^9)
testMat <- hitMat.calc.nBT(Edges, vGoal, 9, 1,2,3^9)
testMat$goalprob
testMat$goalprob[3]
debug(hitMat.calc.nBT)
hitMat.calc.nBT(Edges, vGoal, 9, 1,2,3^9)
hitMat
hitMat.calc.nBT <- function(Edges, vGoal, nSteps, curV, preV, totP){
# nSteps here identifies the total steps AFTER the current event
#   The first step from preV -> curV is not counted!
hitMat <- data.frame(preVertex = preV, Vertex = curV, steps = 1:nSteps, goalprob = 0)
queue <- list(c(preV,curV))
while(length(queue)>0){
pCur <- queue[[1]]
if(length(pCur) == (nSteps+1) & vGoal %in% Edges[[tail(pCur,1)]]){
hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==(length(pCur)-1),]$goalprob <- hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==(length(pCur)-1),]$goalprob + 3^( nSteps - length(pCur) + 1)
}else if(length(pCur) < (nSteps+1)){
for(t in Edges[[tail(pCur,1)]][-which(Edges[[tail(pCur,1)]]==tail(pCur,2)[1])]){
if(t == vGoal){
hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==(length(pCur)-1),]$goalprob <- hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==(length(pCur)-1),]$goalprob + 3^( nSteps - length(pCur) + 1)
}else{
queue <- append(queue, list(c(pCur,t)))
}
}
}
queue[[1]] <- NULL
}
hitMat$goalprob <- hitMat$goalprob / totP
return(hitMat)
}
hitMat.calc.nBT(Edges, vGoal, 9, 1, 2, 3^9)
700 / 3^9
244 / 3^9
(244*3^1) / 3^9
(1*3^(9-3)) / 3^9
testMat <- hitMat.calc.nBT(Edges, vGoal, 9, 1, 2, 3^9)
sum(testMat$goalprob)
(9*3^(9-5)) / 3^9
load("C:/Users/wient/OneDrive - UGent/Projects/ModularGraphs-RL/Rsims/data/4ag_100tr_RLexplore.RData")
############################################################################################################################
################################# Analysis of Modular Graph with costs and rewards #########################################
############################################################################################################################
library(ggplot2)
library(reshape2)
library(ggthemes)
library(RColorBrewer)
library(ggstance)
library(lemon)
# Starting node and goal (rewarded) termination node
vStart <- 1
vGoal  <- 8
# Full edges matrix (schapiro-style random walk)
Edges <- list(c(2, 3, 4, 5),
c(1, 3, 4, 5),
c(1, 2, 4, 5),
c(1, 2, 3, 6),
c(1, 2, 3, 15),
c(4, 7, 8, 9),
c(6, 8, 9, 10),
c(6, 7, 9, 10),
c(6, 7, 8, 10),
c(11,7, 8, 9),
c(10,12,13,14),
c(11,13,14,15),
c(11,12,14,15),
c(11,12,13,15),
c(5, 12,13,14))
ggplot(AG.dat.ppEval, aes(x=totRew, col=strat)) +
geom_density()
load("C:/Users/wient/OneDrive - UGent/Projects/ModularGraphs-RL/Rsims/data/MC_Rew_noBT_data.RData")
ggplot(AG.dat.ppEval, aes(x=totRew, col=strat)) +
geom_density()
ggplot(AG.dat.ppEval, aes(x=totRew, col=strat)) +
geom_density() +
facet_grid(reward~cost)
load("C:/Users/wient/OneDrive - UGent/Projects/ModularGraphs-RL/Rsims/data/4ag_100tr_RLexplore.RData")
ggplot(AG.dat.ppEval, aes(x=totRew, col=strat)) +
geom_density() +
facet_grid(reward~cost)
hitMat.calc.nBT <- function(Edges, vGoal, nSteps, curV, preV, totP){
# nSteps here identifies the total steps AFTER the current event
#   The first step from preV -> curV is not counted!
hitMat <- data.frame(preVertex = preV, Vertex = curV, steps = 1:nSteps, goalprob = 0)
queue <- list(c(preV,curV))
while(length(queue)>0){
pCur <- queue[[1]]
if(length(pCur) == (nSteps+1) & vGoal %in% Edges[[tail(pCur,1)]]){
hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==(length(pCur)-1),]$goalprob <- hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==(length(pCur)-1),]$goalprob + 3^( nSteps - length(pCur) + 1)
}else if(length(pCur) < (nSteps+1)){
for(t in Edges[[tail(pCur,1)]][-which(Edges[[tail(pCur,1)]]==tail(pCur,2)[1])]){
if(t == vGoal){
hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==(length(pCur)-1),]$goalprob <- hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==(length(pCur)-1),]$goalprob + 3^( nSteps - length(pCur) + 1)
}else{
queue <- append(queue, list(c(pCur,t)))
}
}
}
queue[[1]] <- NULL
}
hitMat$goalprob <- hitMat$goalprob / totP
return(hitMat)
}
hitMat.calc.nBT(Edges, vGoal, 9, 1, 2, 3^9)
hitMat.calc.nBT(Edges=Edges, vGoal=vGoal, nSteps=9, curV=1, preV=2, totP=3^9)
list(c(1,2), c(1,4), c(1,5), c(4,1), c(4,6), c(5,1), c(5,15), c(6,4), c(6,7), c(7,6), c(7,9))
testList <- list(c(1,2), c(1,4), c(1,5), c(4,1), c(4,6), c(5,1), c(5,15), c(6,4), c(6,7), c(7,6), c(7,9))
testList[[2]]
hitMat.calc.nBT(Edges=Edges, vGoal=vGoal, nSteps=9, curV=1, preV=2, totP=3^9)
hitMat.calc.nBT(Edges=Edges, vGoal=vGoal, nSteps=9, curV=1, preV=2, totP=3^9)
hitMat <- data.frame(preVertex=0, Vertex=0, steps=0, goalprob=0)
for(comb in list(c(1,2), c(1,4), c(1,5), c(4,1), c(4,6), c(5,1), c(5,15), c(6,4), c(6,7), c(7,6), c(7,9))){
hitMat <- rbind(hitMat, hitMat.calc.nBT(Edges=Edges, vGoal=vGoal, nSteps=9, curV=comb[1], preV=comb[2], totP=3^9))
}
hitMat
hitMat <- hitMat[-1,]
printwd
?write.csv
write.csv(hitMat, file='data/hitMat_nBT_step9')
write.csv(hitMat, file='data/hitMat_nBT_step9.csv')
read.csv('data/hitMat_nBT_step9.csv')
?read.csv
write.csv(hitMat, file='data/hitMat_nBT_step9.csv', row_names=1)
write.csv(hitMat, file='data/hitMat_nBT_step9.csv', row.names=1)
read.csv('data/hitMat_nBT_step9.csv', row.names=1)
176/3^9
# Function that calculates the hit matrix from a graph for the desired transitions
hitMat.calc <- function(Edges, vGoal, nSteps, inspectVs, totP){
hitMat <- data.frame(vertex = rep(inspectVs, each=nSteps), steps = rep(1:nSteps, length(inspectVs)), goalprob = 0)
for(V in inspectVs){
queue   <- list(V)
while(length(queue) > 0){
pCur <- queue[[1]]
if(length(pCur) == nSteps & vGoal %in% Edges[[tail(pCur,1)]]){
hitMat[hitMat$vertex==V & hitMat$steps==length(pCur),]$goalprob <- hitMat[hitMat$vertex==V & hitMat$steps==length(pCur),]$goalprob + length(Edges[[tail(pCur,1)]])^( nSteps - length(pCur) )
}else if(length(pCur) < nSteps){
for(t in Edges[[tail(pCur,1)]]){
if(t == vGoal){
hitMat[hitMat$vertex==V & hitMat$steps==length(pCur),]$goalprob <- hitMat[hitMat$vertex==V & hitMat$steps==length(pCur),]$goalprob + length(Edges[[tail(pCur,1)]])^( nSteps - length(pCur) ) #Length pCur works because the addition of t to the path compensates for the fact that we have one more state vs transition
}else{
queue <- append(queue, list(c(pCur,t)))
}
}
}
queue[[1]] <- NULL
}
}
hitMat$goalprob <- hitMat$goalprob / totP
return(hitMat)
}
# Starting node and goal (rewarded) termination node
vStart <- 1
vGoal  <- 8
# Full edges matrix (schapiro-style random walk)
Edges <- list(c(2, 3, 4, 5),
c(1, 3, 4, 5),
c(1, 2, 4, 5),
c(1, 2, 3, 6),
c(1, 2, 3, 15),
c(4, 7, 8, 9),
c(6, 8, 9, 10),
c(6, 7, 9, 10),
c(6, 7, 8, 10),
c(11,7, 8, 9),
c(10,12,13,14),
c(11,13,14,15),
c(11,12,14,15),
c(11,12,13,15),
c(5, 12,13,14))
hitMat.calc(Edges, vGoal, 9, 1, 4^9)
hitMat.calc(Edges, vGoal, 7, 1, 4^7)
hitMat.calc.nBT <- function(Edges, vGoal, nSteps, curV, preV, totP){
# nSteps here identifies the total steps AFTER the current event
#   The first step from preV -> curV is not counted!
hitMat <- data.frame(preVertex = preV, Vertex = curV, steps = 1:nSteps, goalprob = 0)
queue <- list(c(preV,curV))
while(length(queue)>0){
pCur <- queue[[1]]
if(length(pCur) == (nSteps+1) & vGoal %in% Edges[[tail(pCur,1)]]){
hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==(length(pCur)-1),]$goalprob <- hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==(length(pCur)-1),]$goalprob + (length(Edges[[tail(pCur,1)]])-1)^( nSteps - length(pCur) + 1)
}else if(length(pCur) < (nSteps+1)){
for(t in Edges[[tail(pCur,1)]][-which(Edges[[tail(pCur,1)]]==tail(pCur,2)[1])]){
if(t == vGoal){
hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==(length(pCur)-1),]$goalprob <- hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==(length(pCur)-1),]$goalprob + (length(Edges[[tail(pCur,1)]])-1)^( nSteps - length(pCur) + 1)
}else{
queue <- append(queue, list(c(pCur,t)))
}
}
}
queue[[1]] <- NULL
}
hitMat$goalprob <- hitMat$goalprob / totP
return(hitMat)
}
hitMat.calc.nBT(Edges, vGoal, 9, 1,2,3^9)
class(list(c(1,2)))
class(list(c(1,2)))=='list'
hitMat.calc.nBT(Edges,vGoal,10,1,0,(4*3^9))
Edges
hitMat.calc.nBT(Edges,vGoal,10,1,0,(4*3^9))
debug(hitMat.calc.nBT)
hitMat.calc.nBT(Edges,vGoal,10,1,0,(4*3^9))
totP
curV
preV
hitMat
queue
nSteps
queue
hitMat.calc.nBT(Edges,vGoal,10,1,0,(4*3^9))
queue
pCur
length(pCur)
nSteps_1
nSteps+1
Edges[[tail(pCur,1)]]
which(Edges[[tail(pCur,1)]]==tail(pCur,2)[1])
Edges[[tail(pCur,1)]][-which(Edges[[tail(pCur,1)]]==tail(pCur,2)[1])]
c(1,2,3,4)[3]
c(1,2,3,4)[-0]
undebug(hitMat.calc.nBT)
hitMat.calc.nBT(Edges,vGoal,9,1,2,(3^9))
hitMat <- hitMat.calc.nBT(Edges,vGoal,9,1,2,(3^9))
hitMat
EVcalc.nBT <- function(Edges, curV, preV, vGoal, nSteps, gRew, sCost, hitMat=F){
if(hitMat==F){
hitMat <- hitMat.calc.nBT(Edges=Edges, vGoal=vGoal, nSteps=nSteps, curV=curV, preV=preV, totP=3^nStep)
}
if(nSteps != max(hitMat$steps)){
stop('Wrong hitmat specification')
}
EVdat <- data.frame(preVertex = preV, Vertex = curV, steps=1:nSteps, EV=0)
for(leftSteps in 1:nSteps){
intRew <- (1-sum(hitMat[preVertex==preV & Vertex==curV & steps<=leftSteps,]$goalprob)) * (-sCost * leftSteps)
for(i in 1:leftSteps){
intRew <- intRew + hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==i,]$goalprob * (gRew - sCost*i)
}
EVdat[EVdat$preVertex==preV & EVdat$Vertex==curV & EVdat$steps==leftSteps,]$EV = intRew
}
return(EVdat)
}
EVcalc.nBT(Edges, 1, 2, 8, 9, 7, 0.15, hitMat)
hitMat
EVcalc.nBT <- function(Edges, curV, preV, vGoal, nSteps, gRew, sCost, hitMat=F){
if(hitMat==F){
hitMat <- hitMat.calc.nBT(Edges=Edges, vGoal=vGoal, nSteps=nSteps, curV=curV, preV=preV, totP=3^nStep)
}
if(nSteps != max(hitMat$steps)){
stop('Wrong hitmat specification')
}
EVdat <- data.frame(preVertex = preV, Vertex = curV, steps=1:nSteps, EV=0)
for(leftSteps in 1:nSteps){
intRew <- (1-sum(hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps<=leftSteps,]$goalprob)) * (-sCost * leftSteps)
for(i in 1:leftSteps){
intRew <- intRew + hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==i,]$goalprob * (gRew - sCost*i)
}
EVdat[EVdat$preVertex==preV & EVdat$Vertex==curV & EVdat$steps==leftSteps,]$EV = intRew
}
return(EVdat)
}
EVcalc.nBT(Edges, 1, 2, 8, 9, 7, 0.15, hitMat)
EVcalc.nBT <- function(Edges, curV, preV, vGoal, nSteps, gRew, sCost, hitMat=F){
if(!class(hitMat) %in% 'data.frame'){
hitMat <- hitMat.calc.nBT(Edges=Edges, vGoal=vGoal, nSteps=nSteps, curV=curV, preV=preV, totP=3^nStep)
}
if(nSteps != max(hitMat$steps)){
stop('Wrong hitmat specification')
}
EVdat <- data.frame(preVertex = preV, Vertex = curV, steps=1:nSteps, EV=0)
for(leftSteps in 1:nSteps){
intRew <- (1-sum(hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps<=leftSteps,]$goalprob)) * (-sCost * leftSteps)
for(i in 1:leftSteps){
intRew <- intRew + hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==i,]$goalprob * (gRew - sCost*i)
}
EVdat[EVdat$preVertex==preV & EVdat$Vertex==curV & EVdat$steps==leftSteps,]$EV = intRew
}
return(EVdat)
}
EVcalc.nBT(Edges, 1, 2, 8, 9, 7, 0.15, hitMat)
# Function that ouptputs a Data Frame of expected values per state-step conjunction
EVcalc <- function(Edges, vStart, vGoal, nSteps, gRew, sCost, hitMat=F, goalstepchance=F, inspect.Edges=F){
# Brute-force a full HitMat if not provided (add later)
if(!class(hitMat) %in% c( 'matrix', 'data.frame')){
stop('You have not provided a hit-matrix. Currently the flexible calculation of a hit-matrix is not supported by this function.')
}
# Brute-force the chances of hitting from the starting position if not provided (for now dependent on Schapiro)
if(class(goalstepchance) != 'numeric'){
print('No information is provided about goal-attainment from starting position. Calculated using Schapiro-style layout.')
# Get starting expectations
propStart <- rep(0,length(1:(nSteps+1)))
for(nV in 1:(nSteps+1)){
paths   <- 0
queue   <- list(c(0,1))
while(length(queue) > 0){
pCur <- queue[[1]]
for(t in Edges[[tail(pCur,1)]]){
if(t!= tail(pCur,2)[1] & length(c(pCur,t))<(nV+1)){         #No-backtrack
#if(length(c(pCur,t))<nV){                              #Backtrack
queue <- append(queue,list(c(pCur,t)))
}else if(t!= tail(pCur,2)[1] & length(c(pCur,t))==(nV+1)){  #No-backtrack
#}else if(length(c(pCur,t))==nV){                       #Backtrack
paths <- paths+1
if(vGoal == t & !vGoal %in% pCur){
propStart[nV] <- propStart[nV]+1
}
}
}
queue[[1]] <- NULL
}
}
propStart <- propStart[-1]
goalstepchance <- rep(0,10)
for(nSteps in 1:nSteps){
goalstepchance[nSteps] <- propStart[nSteps]/(4*3^(nSteps-1))
}
}
# Check if we know relevant edges to inspect
if(inspect.Edges==F & !class(hitMat) %in% c('matrix','data.frame')){
stop('You must either provide a hit-matrix containing the edges you wish to inspect as row names, or a list of Edges you wish to inspect.')
}
# Check if edges are legal in provided graph (edge list)
EVmat <- matrix(nrow=nrow(hitMat.nBT), ncol=ncol(hitMat.nBT))
rownames(EVmat) <- rownames(hitMat.nBT)
colnames(EVmat) <- colnames(hitMat.nBT)
for(leftSteps in 1:ncol(hitMat.nBT)){
for(transid in rownames(hitMat.nBT)){
intRew <- 0
goalProb.s <- rep(0,leftSteps)
for(s in 1:leftSteps){
goalProb.s[s] <- hitMat.nBT[transid,s]/(3^s)
intRew <- intRew + goalProb.s[s] * (gRew-(sCost*s))
}
EV <- intRew - (1-sum(goalProb.s))*sCost*leftSteps
EVmat[transid,leftSteps] <- EV
}
}
EVdat <- melt(EVmat, varnames=c('trans','sLeft'))
EVdat <- rbind(EVdat, data.frame(trans='1<-|',sLeft=10,value=sum(goalstepchance * (gRew-(c(1:10)*sCost))) - ((1-sum(goalstepchance))*(10*sCost))))
EVdat$trans <- factor(EVdat$trans, levels=c(as.character(EVdat[EVdat$sLeft==9,][order(-EVdat[EVdat$sLeft==9,]$value),]$trans),'1<-|'), ordered=T)
return(EVdat)
}
hitMat.nBT  <- read.csv('data/no-BT_step-9_hit_unique.csv',row.names=1,check.names=F)
############################################################################################################################
## Plot the EVs over different transitions for different steps ----
EV_data <- EVcalc(Edges = Edges, vStart=vStart, vGoal=vGoal, nSteps=10, gRew=7, sCost=0.15, hitMat=hitMat.nBT, goalstepchance=goalstepchance)
## Precalc goalstepchange ----
# Get starting expectations
propStart <- rep(0,length(1:11))
for(nV in 1:11){
paths   <- 0
queue   <- list(c(0,1))
while(length(queue) > 0){
pCur <- queue[[1]]
for(t in Edges[[tail(pCur,1)]]){
if(t!= tail(pCur,2)[1] & length(c(pCur,t))<(nV+1)){         #No-backtrack
#if(length(c(pCur,t))<nV){                              #Backtrack
queue <- append(queue,list(c(pCur,t)))
}else if(t!= tail(pCur,2)[1] & length(c(pCur,t))==(nV+1)){  #No-backtrack
#}else if(length(c(pCur,t))==nV){                       #Backtrack
paths <- paths+1
if(vGoal == t & !vGoal %in% pCur){
propStart[nV] <- propStart[nV]+1
}
}
}
queue[[1]] <- NULL
}
}
propStart <- propStart[-1]
goalstepchance <- rep(0,10)
for(nSteps in 1:10){
goalstepchance[nSteps] <- propStart[nSteps]/(4*3^(nSteps-1))
}
############################################################################################################################
## Plot the EVs over different transitions for different steps ----
EV_data <- EVcalc(Edges = Edges, vStart=vStart, vGoal=vGoal, nSteps=10, gRew=7, sCost=0.15, hitMat=hitMat.nBT, goalstepchance=goalstepchance)
EV_data
EV_data[EV_data$trans=='1<-2',]
EVcalc.nBT(Edges, 1, 2, 8, 9, 7, 0.15, hitMat)
hitMat.nBT  <- read.csv('data/hitMat_nBT_step9.csv',row.names=1,check.names=F)
hitMat.nBT
hitMat.nBT
levels(hitMat.nBT$preVertex)
unique(hitMat.nBT[,c('preVertex','Vertex')])
apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, print)
apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, print)
apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 2, print)
apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 2, sum)
apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, sum)
apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, function(x){print(x[1])})
apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, function(x){EVcalc.nBT(Edges=Edges, vStart=vStart, vGoal=vGoal, nSteps=10, gRew=7, sCost=0.15, hitMat=hitMat.nBT)})
unique(hitMat.nBT[,c('preVertex','Vertex')])
apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, function(x){EVcalc.nBT(Edges=Edges, preV=x[1], curV=x[2], vGoal=vGoal, nSteps=10, gRew=7, sCost=0.15, hitMat=hitMat.nBT)})
apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, function(x){EVcalc.nBT(Edges=Edges, preV=x[1], curV=x[2], vGoal=vGoal, nSteps=10, gRew=7, sCost=0.15, hitMat=hitMat.nBT)})[1,]
unique(hitMat.nBT[,c('preVertex','Vertex')])
unique(hitMat.nBT[,c('preVertex','Vertex')])[1,]
unique(hitMat.nBT[,c('preVertex','Vertex')])[1,][1]
unique(hitMat.nBT[,c('preVertex','Vertex')])[1,][2]
unique(hitMat.nBT[,c('preVertex','Vertex')])[1,][1] + 4
apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, function(x){EVcalc.nBT(Edges=Edges, preV=x[1], curV=x[2], vGoal=vGoal, nSteps=9, gRew=7, sCost=0.15, hitMat=hitMat.nBT)})
warnings()
EV_data
EV_data2 <- apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, function(x){EVcalc.nBT(Edges=Edges, preV=x[1], curV=x[2], vGoal=vGoal, nSteps=9, gRew=7, sCost=0.15, hitMat=hitMat.nBT)})
EV_data
EV_data[EV_data$trans=='1<-2',]
apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, function(x){EVcalc.nBT(Edges=Edges, preV=x[1], curV=x[2], vGoal=vGoal, nSteps=9, gRew=7, sCost=0.15, hitMat=hitMat.nBT)})
rbind(apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, function(x){EVcalc.nBT(Edges=Edges, preV=x[1], curV=x[2], vGoal=vGoal, nSteps=9, gRew=7, sCost=0.15, hitMat=hitMat.nBT)}))
apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, function(x){EVcalc.nBT(Edges=Edges, preV=x[1], curV=x[2], vGoal=vGoal, nSteps=9, gRew=7, sCost=0.15, hitMat=hitMat.nBT)})
sapply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, function(x){EVcalc.nBT(Edges=Edges, preV=x[1], curV=x[2], vGoal=vGoal, nSteps=9, gRew=7, sCost=0.15, hitMat=hitMat.nBT)})
EV_data2 <- sapply(unique(hitMat.nBT[,c('preVertex','Vertex')]), function(x){EVcalc.nBT(Edges=Edges, preV=x[1], curV=x[2], vGoal=vGoal, nSteps=9, gRew=7, sCost=0.15, hitMat=hitMat.nBT)})
EV_data2 <- apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, function(x){EVcalc.nBT(Edges=Edges, preV=x[1], curV=x[2], vGoal=vGoal, nSteps=9, gRew=7, sCost=0.15, hitMat=hitMat.nBT)})
do.call('rbind', apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, function(x){EVcalc.nBT(Edges=Edges, preV=x[1], curV=x[2], vGoal=vGoal, nSteps=9, gRew=7, sCost=0.15, hitMat=hitMat.nBT)}))
warnings()
hitMat.nBT
rownames(hitMat.nBT) <- NULL
hitMat.nBT
EV_data2 <- apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, function(x){EVcalc.nBT(Edges=Edges, preV=x[1], curV=x[2], vGoal=vGoal, nSteps=9, gRew=7, sCost=0.15, hitMat=hitMat.nBT)})
warnings
warnings()
apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, function(x){EVcalc.nBT(Edges=Edges, preV=x[1], curV=x[2], vGoal=vGoal, nSteps=9, gRew=7, sCost=0.15, hitMat=hitMat.nBT)})
?apply
warnings()
as.integer(1)
EV_data2 <- apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, function(x){EVcalc.nBT(Edges=Edges, preV=as.integer(x[1]), curV=as.integer(x[2]), vGoal=vGoal, nSteps=9, gRew=7, sCost=0.15, hitMat=hitMat.nBT)})
EV_data2
EV_data2 <- do.call('rbind', apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, function(x){EVcalc.nBT(Edges=Edges, preV=as.integer(x[1]), curV=as.integer(x[2]), vGoal=vGoal, nSteps=9, gRew=7, sCost=0.15, hitMat=hitMat.nBT)}))
EV_data2
EV_plot
EV_data
EV_data2
interaction(EV_data2$preVertex, EV_data2$Vertex)
############################################################################################################################
## Plot the EVs over different transitions for different steps ----
EV_data <- do.call('rbind', apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, function(x){EVcalc.nBT(Edges=Edges, preV=as.integer(x[1]), curV=as.integer(x[2]), vGoal=vGoal, nSteps=9, gRew=7, sCost=0.15, hitMat=hitMat.nBT)}))
############################################################################################################################
################################# Analysis of Modular Graph with costs and rewards #########################################
############################################################################################################################
library(ggplot2)
library(reshape2)
library(ggthemes)
library(RColorBrewer)
library(ggstance)
library(lemon)
############################################################################################################################
## Plot the EVs over different transitions for different steps ----
EVdat <- do.call('rbind', apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, function(x){EVcalc.nBT(Edges=Edges, preV=as.integer(x[1]), curV=as.integer(x[2]), vGoal=vGoal, nSteps=9, gRew=7, sCost=0.15, hitMat=hitMat.nBT)}))
EVdat
ggplot(EVdat, aes(x=sLeft, y=EV, color=interaction(preVertex,Vertex))) +
geom_line(aes(group=interaction(preVertex,Vertex))) +
geom_point()
ggplot(EVdat, aes(x=steps, y=EV, color=interaction(preVertex,Vertex))) +
geom_line(aes(group=interaction(preVertex,Vertex))) +
geom_point()
EVdat
rownames(EVdat) <- NULL
EVdat
EVcalc.nBT <- function(Edges, curV, preV, vGoal, nSteps, gRew, sCost, hitMat=F){
if(!class(hitMat) %in% 'data.frame'){
hitMat <- hitMat.calc.nBT(Edges=Edges, vGoal=vGoal, nSteps=nSteps, curV=curV, preV=preV, totP=3^nStep)
}
if(nSteps != max(hitMat$steps)){
stop('Wrong hitmat specification')
}
EVdat <- data.frame(preVertex = preV, Vertex = curV, steps=1:nSteps, EV=0)
for(leftSteps in 1:nSteps){
intRew <- (1-sum(hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps<=leftSteps,]$goalprob)) * (-sCost * leftSteps)
for(i in 1:leftSteps){
intRew <- intRew + hitMat[hitMat$preVertex==preV & hitMat$Vertex==curV & hitMat$steps==i,]$goalprob * (gRew - sCost*i)
}
EVdat[EVdat$preVertex==preV & EVdat$Vertex==curV & EVdat$steps==leftSteps,]$EV = intRew
}
return(EVdat)
}
############################################################################################################################
## Plot the EVs over different transitions for different steps ----
EVdat <- do.call('rbind', apply(unique(hitMat.nBT[,c('preVertex','Vertex')]), 1, function(x){EVcalc.nBT(Edges=Edges, preV=as.integer(x[1]), curV=as.integer(x[2]), vGoal=vGoal, nSteps=9, gRew=7, sCost=0.15, hitMat=hitMat.nBT)}))
rownames(EVdat) <- NULL
EVplot(EV_data)
EVdat
