c(16,18,19,20),
c(16,17,19,20),
c(16,17,18,20),
c(17,18,19, 1))
# Load Functions from /src/
sapply(paste0('src/',list.files('src/')), source)
# Define point multiplier for winning
winM   <- 5
startP <- 5
nVisit <- 15
nTr    <- 100
nPP    <- 500
#Quad Schapiro-style edge matrix
Edges <- list(c(2, 3, 4, 20),
c(1, 3, 4, 5),
c(1, 2, 4, 5),
c(1, 2, 3, 5),
c(2, 3, 4, 6),
c(5, 7, 8, 9),
c(6, 8, 9, 10),
c(6, 7, 9, 10),
c(6, 7, 8, 10),
c(7, 8, 9, 11),
c(10,12,13,14),
c(11,13,14,15),
c(11,12,14,15),
c(11,12,13,15),
c(12,13,14,16),
c(15,17,18,19),
c(16,18,19,20),
c(16,17,19,20),
c(16,17,18,20),
c(17,18,19, 1))
# Get vertex / edge mappings w.r.t. different goals
idmap.d  <- list(a = c(1,15), b = c(2,3,4, 12,13,14), c = c(5,11), d = c(6,10), e = c(7,9), f = c(16,20), g = c(17,18,19))
idmap.bg <- list(a = c(1), b = c(2,3,4), c = c(5), d = c(7,8,9), e = c(10), f = c(11), g = c(12,13,14), h = c(15), i = c(16), j = c(17,18,19), k = c(20))
idmap.g  <- list(a = c(2,3,4), b = c(7,8,9), c = c(12,13,14), d = c(17,18,19))
c.map    <- list(a = c('d','b'), b = c('a', 'c'), c = c('b','d'), d=c('a','c'))
bt.map   <- list(a = c(1,5), b = c(6,10), c= c(11,15), d=c(20,16))
# Get hitMats
hitMat.d <- as.data.table(read.csv('data/hitMat_quadSchap_step15.csv', row.names=1))
hitMat.b <- as.data.table(read.csv('data/hitMat_quadSchap_step15_btgl.csv', row.names=1))
# Calculate EV for different nodes
EVmat.d <- foreach(v = unique(hitMat.d$vertex), .combine=rbind) %do% {
tempMat <- EVbet.calc(Edges=Edges, nSteps=nVisit-1, winM=winM, hitMat=hitMat.d, Vertex=v)
tempMat
}
EVmat.b <- foreach(v = unique(hitMat.b$vertex), .combine=rbind) %do% {
tempMat <- EVbet.calc(Edges=Edges, nSteps=nVisit-1, winM=winM, hitMat=hitMat.b, Vertex=v)
tempMat
}
# Get policies for the deep & bottleneck node EVmats
stopIdx.d <- EVmat.d[, EV<0,by=.(vertex,steps)
][,if(TRUE %in% V1){
.SD[V1==T,max(steps)]
}else{
as.integer(0)
},
by=vertex
]
stopIdx.b <- EVmat.b[, EV<0,by=.(vertex,steps)
][,if(TRUE %in% V1){
.SD[V1==T,max(steps)]
}else{
as.integer(0)
},
by=vertex
]
nPP
## Get simulated trajectories ----
full.exp <- foreach(p = 1:nPP, .combine=rbind) %do% {
# Initialize experimental experience
full.exp <- Bet.gen(Edges, nVisit, nTr, c.map, idmap.g, bt.map, parNum=p)
# Get cluster info
full.exp[, goal.c:=substring(names(which(sapply(unlist(c(idmap.g, bt.map), use.names=T), function(m){goal[1] %in% m}))),1,1), by=tr
][, start.c:=substring(names(which(sapply(unlist(c(idmap.g, bt.map), use.names=T), function(m){v[1] %in% m}))),1,1), by=tr]
# Get mirror symmetry identity w.r.t. goal
full.exp[, sym.id:=symmetry.get(v, goal, goal.c, idmap.g, bt.map, c.map, idmap.d, idmap.bg), by=.(pp,tr,stepsleft)]
# Define random strategy
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)       #Sample random choice increments
][,rand.trBet := na.locf(bet.sum(rand.choice,startP)),by=tr       #Add up to get bets, with startP starting points
][stepsleft == 0, rand.trRew := -rand.trBet, by=tr              #Determine losing bets
][v==goal, rand.trRew := winM*rand.trBet, by=tr               #Determine winning bets
][!is.na(rand.trRew),rand.totRew := cumsum(rand.trRew)]     #Add up all losses and wins
# Define modular strategy
full.exp[v!=goal, mod.choice:=if(v %in% unlist(c(idmap.g[c(goal.c,start.c)], bt.map[c(goal.c,start.c)]))){1}else{-1}, by=.(tr,stepsleft)  # Determine modular choice (start+goal)
][,mod.trBet := na.locf(bet.sum(mod.choice, startP)),by=tr                                                                       # Add up to get bets, with startP starting points
][stepsleft == 0, mod.trRew := -mod.trBet, by=tr                                                                               # Determine losing bets
][v==goal, mod.trRew := winM*mod.trBet, by=tr                                                                                # Determine winning bets
][!is.na(mod.trRew),mod.totRew := cumsum(mod.trRew)]                                                                       # Add up all losses and wins
# Define optimal strategy
full.exp[!is.na(sym.id),opt.choice:=if(trtype=='deep'){
if(stepsleft > stopIdx.d[vertex%in%idmap.d[[sym.id]]]$V1){
1
}else{
-1
}
}else{
if(stepsleft > stopIdx.b[vertex%in%idmap.bg[[sym.id]]]$V1){
1
}else{
-1
}
}, by=.(pp,tr,stepsleft)
][,opt.trBet := na.locf(bet.sum(opt.choice, startP)),by=tr      # Add up to get bets, with startP starting points
][stepsleft == 0, opt.trRew := -opt.trBet, by=tr              # Determine losing bets
][v==goal, opt.trRew := winM*opt.trBet, by=tr               # Determine winning bets
][!is.na(opt.trRew),opt.totRew := cumsum(opt.trRew)]      # Add up all losses and wins
return(full.exp)
}
save(full.exp, bt.map, c.map, Edges, EVmat.b, EVmat.d, hitMat.b, hitMat.d, idmap.bg, idmap.d, idmap.g, stopIdx.b, stopIdx.d, file='data/QuadMod-Bet_testDat-1.RData')
# Load Functions from /src/
load('data/QuadMod-Bet_testDat-1.RData')
############################################################################################################################
####################### Script for fitting Stan models to different betting datasets QuadMod ###############################
############################################################################################################################
library(foreach)
library(ggplot2)
library(reshape2)
library(data.table)
library(zoo)
library(rstan)
library(bayesplot)
# Load Functions from /src/
load('data/QuadMod-Bet_testDat-1.RData')
sapply(paste0('src/',list.files('src/')), source)
# Define point multiplier for winning
winM   <- 5
startP <- 5
nVisit <- 15
nTr    <- 100
nPP    <- 500
# Get policy used (defines different stopping behaviours / symmetries)
full.exp[,pol.type:=if(trtype=='deep'){'deep'}else{'bottleneck'},by=.(pp,tr,stepsleft)]
full.exp
# Load Functions from /src/
load('data/QuadMod-Bet_testDat-1.RData')
full.exp
## Model that will fit similar values as Binomial but uses Bernoulli - check for speedup ----
bern.exp <- full.exp
noiseL <- 0.1
bern.exp[,stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL)),]
bern.exp[,sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL)),]
bern.exp[,sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL)),by=.(pp,tr,stepsleft)]
bern.exp[,list(stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL))),by=.(pp,tr,stepsleft)]
bern.exp[,list(stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL))),by=.(pp,tr,stepsleft)
][,list(stan.opt.choice=if(stan.opt.choice==-1){0}else{1}),by=.(pp,tr,stepsleft)]
warnings
warnings()
bern.exp
bern.exp[,list(stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL))),by=.(pp,tr,stepsleft)
]
bern.exp
bern.exp[,list(stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL))),by=.(pp,tr,stepsleft)]
bern.exp[,list(stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL))),by=.(pp,tr,stepsleft)][,list(stan.opt.choice=if(.SD[,stan.opt.choice]==-1){0}else{1})]
bern.exp[,list(stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL))),by=.(pp,tr,stepsleft)][,list(stan.opt.choice=if(.SD[,stan.opt.choice]==-1){0}else{1}), by=.(pp,tr,stepsleft)]
bern.exp[,list(stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL))),by=.(pp,tr,stepsleft)][,list(wow.opt.choice=if(.SD[,stan.opt.choice]==-1){0}else{1}), by=.(pp,tr,stepsleft)]
bern.exp[,list(stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL))),by=.(pp,tr,stepsleft)]
bern.exp[,list(stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL))),by=.(pp,tr,stepsleft)
][stan.opt.choice==-1, stan.opt.choice=0]
bern.exp[,list(stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL))),by=.(pp,tr,stepsleft)
][stan.opt.choice==-1, list(stan.opt.choice=0)]
bern.exp[,list(stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL))),by=.(pp,tr,stepsleft)
][stan.opt.choice==-1, ]
bern.exp[,list(stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL))),by=.(pp,tr,stepsleft)
][stan.opt.choice==-1, stan.opt.choice:=0]
bern.exp
bern.exp[,list(stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL))),by=.(pp,tr,stepsleft)
][stan.opt.choice==-1, stan.opt.choice:=0
][,list(pp,tr,stepsleft,stan.opt.choice)]
bern.exp[,list(stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL))),by=.(pp,tr,stepsleft)
]
?sample
bern.exp[,list(stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL), size=1)),by=.(pp,tr,stepsleft)
][stan.opt.choice==-1, stan.opt.choice:=0
][,list(pp,tr,stepsleft,stan.opt.choice)]
bern.exp <- full.exp[,list(stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL), size=1)),by=.(pp,tr,stepsleft)
][stan.opt.choice==-1, stan.opt.choice:=0
][,list(pp,tr,stepsleft,stan.opt.choice)]
bern.exp
full.exp
bern.exp <- full.exp[,list(stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL), size=1)),by=.(pp,tr,stepsleft)
][stan.opt.choice==-1, stan.opt.choice:=0
][,list(pp,tr,stepsleft,stan.opt.choice, reg.id=interaction(pp,tr,stepsleft))]
bern.exp
bern.exp <- full.exp[,list(stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL), size=1)),by=.(pp,tr,stepsleft)
][stan.opt.choice==-1, stan.opt.choice:=0
][,list(pp,tr,stepsleft,stan.opt.choice, reg.id=interaction(sym.id,stepsleft))]
bern.exp <- full.exp[,list(sym.id,
pol.type=if(trtype=='deep'){'deep'}else{'bottleneck'},
stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL), size=1)),by=.(pp,tr,stepsleft)
][stan.opt.choice==-1, stan.opt.choice:=0
][,list(pp,tr,stepsleft,stan.opt.choice, reg.id=interaction(pol.type,sym.id,stepsleft))]
bern.exp
full.exp
bern.exp
bern.exp <- full.exp[,list(sym.id,
pol.type=if(trtype=='deep'){'deep'}else{'bottleneck'},
stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL), size=1)),by=.(pp,tr,stepsleft)
][stan.opt.choice==-1, stan.opt.choice:=0
][,list(pp,tr,stepsleft,stan.opt.choice, reg.id=interaction(pol.type,sym.id,stepsleft))
][,list(pp,tr,stepsleft,stan.opt.choice,reg.id,reg.code=which(levels(reg.id)))]
bern.exp <- full.exp[,list(sym.id,
pol.type=if(trtype=='deep'){'deep'}else{'bottleneck'},
stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL), size=1)),by=.(pp,tr,stepsleft)
][stan.opt.choice==-1, stan.opt.choice:=0
][,list(pp,tr,stepsleft,stan.opt.choice, reg.id=interaction(pol.type,sym.id,stepsleft))
][,list(pp,tr,stepsleft,stan.opt.choice,reg.id,reg.code=match(reg.id,levels(reg.id)))]
bern.exp
levels(bern.exp$reg.id)
droplevels(bern.exp$reg.id)
bern.exp <- full.exp[,list(sym.id,
pol.type=if(trtype=='deep'){'deep'}else{'bottleneck'},
stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL), size=1)),by=.(pp,tr,stepsleft)
][stan.opt.choice==-1, stan.opt.choice:=0
][,list(pp,tr,stepsleft,stan.opt.choice, reg.id=interaction(pol.type,sym.id,stepsleft))
][,reg.id:=droplevels(reg.id)
][,list(pp,tr,stepsleft,stan.opt.choice,reg.id,reg.code=match(reg.id,levels(reg.id)))]
bern.exp
bern.exp[reg.id=='deep.a.14']
bern.exp[reg.code==1]
bern.exp <- full.exp[pp%in%1:100,list(sym.id,
pol.type=if(trtype=='deep'){'deep'}else{'bottleneck'},
stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL), size=1)),by=.(pp,tr,stepsleft)
][stan.opt.choice==-1, stan.opt.choice:=0
][,list(pp,tr,stepsleft,stan.opt.choice, reg.id=interaction(pol.type,sym.id,stepsleft))
][,reg.id:=droplevels(reg.id)
][,list(pp,tr,stepsleft,stan.opt.choice,reg.id,reg.code=match(reg.id,levels(reg.id)))]
bern.exp
standata_list <- list(
K  = max(bern.exp$reg.code),
M  = nrow(bern.exp),
Vx = bern.exp$reg.code,
y  = bern.exp$stan.opt.choice
)
fit1 <- stan(
file = "src/Stan/sim1test3.stan",
data = standata_list,
chains = 4,
warmup = 1000,
iter = 2000,
cores = 2,
verbose = T
)
bern.exp <- full.exp[pp%in%1:100 & !is.na(opt.choice),list(sym.id,
pol.type=if(trtype=='deep'){'deep'}else{'bottleneck'},
stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL), size=1)),by=.(pp,tr,stepsleft)
][stan.opt.choice==-1, stan.opt.choice:=0
][,list(pp,tr,stepsleft,stan.opt.choice, reg.id=interaction(pol.type,sym.id,stepsleft))
][,reg.id:=droplevels(reg.id)
][,list(pp,tr,stepsleft,stan.opt.choice,reg.id,reg.code=match(reg.id,levels(reg.id)))]
bern.exp
standata_list <- list(
K  = max(bern.exp$reg.code),
M  = nrow(bern.exp),
Vx = bern.exp$reg.code,
y  = bern.exp$stan.opt.choice
)
fit1 <- stan(
file = "src/Stan/sim1test3.stan",
data = standata_list,
chains = 4,
warmup = 1000,
iter = 2000,
cores = 2,
verbose = T
)
fit1
fit1summary <- summary(fit1)$summary
fit1plotdat <- data.table(reg.id = levels(bern.exp$reg.id), meanT=fit1summary[-nrow(fit1summary),1], minT=fit1summary[-nrow(fit1summary),4], maxT=fit1summary[-nrow(fit1summary),8])
fit1plotdat
fit1plotdat[,c('pol.type','sym.id','stepsleft'):=as.list(unlist(strsplit(reg.id, '[.]'))), by=.(reg.id)]
fit1plotdat
ggplot(fit1plotdat, aes(x=stepsleft, y=meanT, group=sym.id, col=sym.id))+
geom_line() +
geom_point() +
geom_errorbar(aes(ymin=lowT, ymax=highT)) +
facet_grid(pol.type~sym.id)
ggplot(fit1plotdat, aes(x=stepsleft, y=meanT, group=sym.id, col=sym.id))+
geom_line() +
geom_point() +
geom_errorbar(aes(ymin=minT, ymax=maxT)) +
facet_grid(pol.type~sym.id)
fit1plotdat[,c('pol.type','sym.id','stepsleft'):=as.list(unlist(strsplit(reg.id, '[.]'))), by=.(reg.id)
][,stepsleft:=as.numeric(stepsleft)]
ggplot(fit1plotdat, aes(x=stepsleft, y=meanT, group=sym.id, col=sym.id))+
geom_line() +
geom_point() +
geom_errorbar(aes(ymin=minT, ymax=maxT)) +
facet_grid(pol.type~sym.id)
fit1 <- stan(
file = "src/Stan/sim1test4.stan",
data = standata_list,
chains = 4,
warmup = 1000,
iter = 2000,
cores = 2,
verbose = T
)
fit1
tail(fit1)
summary(fit1)
fit1
fit1summary <- summary(fit1)$summary
fit1summary
tail(fit1summary)
fit1plotdat <- data.table(reg.id = levels(bern.exp$reg.id), meanT=fit1summary[1:257,1], minT=fit1summary[1:257,4], maxT=fit1summary[1:257,8])
fit1plotdat[,c('pol.type','sym.id','stepsleft'):=as.list(unlist(strsplit(reg.id, '[.]'))), by=.(reg.id)
][,stepsleft:=as.numeric(stepsleft)]
ggplot(fit1plotdat, aes(x=stepsleft, y=meanT, group=sym.id, col=sym.id))+
geom_line() +
geom_point() +
geom_errorbar(aes(ymin=minT, ymax=maxT)) +
facet_grid(pol.type~sym.id)
nrow(fit1summary)
fit1plotdat <- data.table(reg.id = levels(bern.exp$reg.id), meanT=fit1summary[258:514,1], minT=fit1summary[258:514,4], maxT=fit1summary[258:514,8])
fit1plotdat[,c('pol.type','sym.id','stepsleft'):=as.list(unlist(strsplit(reg.id, '[.]'))), by=.(reg.id)
][,stepsleft:=as.numeric(stepsleft)]
ggplot(fit1plotdat, aes(x=stepsleft, y=meanT, group=sym.id, col=sym.id))+
geom_line() +
geom_point() +
geom_errorbar(aes(ymin=minT, ymax=maxT)) +
facet_grid(pol.type~sym.id)
bern.exp
## Model that will fit similar values as Binomial but uses Bernoulli - check for speedup ----
noiseL <- 0.4
bern.exp <- full.exp[pp%in%1:50 & !is.na(opt.choice),list(sym.id,
pol.type=if(trtype=='deep'){'deep'}else{'bottleneck'},
stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL), size=1)),by=.(pp,tr,stepsleft)
][stan.opt.choice==-1, stan.opt.choice:=0
][,list(pp,tr,stepsleft,stan.opt.choice, reg.id=interaction(pol.type,sym.id,stepsleft))
][,reg.id:=droplevels(reg.id)
][,list(pp,tr,stepsleft,stan.opt.choice,reg.id,reg.code=match(reg.id,levels(reg.id)))]
standata_list <- list(
K  = max(bern.exp$reg.code),
M  = nrow(bern.exp),
Vx = bern.exp$reg.code,
y  = bern.exp$stan.opt.choice
)
fit1 <- stan(
file = "src/Stan/sim1test4.stan",
data = standata_list,
chains = 4,
warmup = 1000,
iter = 2000,
cores = 2,
verbose = T
)
fit1summary <- summary(fit1)$summary
fit1plotdat <- data.table(reg.id = levels(bern.exp$reg.id), meanT=fit1summary[258:514,1], minT=fit1summary[258:514,4], maxT=fit1summary[258:514,8])
fit1plotdat[,c('pol.type','sym.id','stepsleft'):=as.list(unlist(strsplit(reg.id, '[.]'))), by=.(reg.id)
][,stepsleft:=as.numeric(stepsleft)]
ggplot(fit1plotdat, aes(x=stepsleft, y=meanT, group=sym.id, col=sym.id))+
geom_line() +
geom_point() +
geom_errorbar(aes(ymin=minT, ymax=maxT)) +
facet_grid(pol.type~sym.id)
bern.exp
## Model that will fit similar values as Binomial but uses Bernoulli - check for speedup ----
noiseL <- 0.1
bern.exp <- full.exp[pp%in%1:100 & !is.na(opt.choice),list(sym.id,
pol.type=if(trtype=='deep'){'deep'}else{'bottleneck'},
stan.opt.choice=sample(c(opt.choice, -opt.choice), prob=c(1-noiseL, noiseL), size=1)),by=.(pp,tr,stepsleft)
][stan.opt.choice==-1, stan.opt.choice:=0
][,list(pp,tr,stepsleft,stan.opt.choice, reg.id=interaction(pol.type,sym.id,stepsleft))
][,reg.id:=droplevels(reg.id)
][,list(pp,tr,stepsleft,stan.opt.choice,reg.id,reg.code=match(reg.id,levels(reg.id)))]
standata_list <- list(
P  = max(bern.exp$pp),
K  = max(bern.exp$reg.code),
M  = nrow(bern.exp),
Vx = bern.exp$reg.code,
y  = bern.exp$stan.opt.choice,
Pn = bern.exp$pp
)
fit1 <- stan(
file = "src/Stan/sim1test5.stan",
data = standata_list,
chains = 4,
warmup = 1000,
iter = 2000,
cores = 2,
verbose = T
)
fit1
fit1summary <- summary(fit1)$summary
fit1plotdat <- data.table(reg.id = levels(bern.exp$reg.id), meanT=fit1summary[1:257,1], minT=fit1summary[1:257,4], maxT=fit1summary[1:257,8])
fit1plotdat[,c('pol.type','sym.id','stepsleft'):=as.list(unlist(strsplit(reg.id, '[.]'))), by=.(reg.id)
][,stepsleft:=as.numeric(stepsleft)]
ggplot(fit1plotdat, aes(x=stepsleft, y=meanT, group=sym.id, col=sym.id))+
geom_line() +
geom_point() +
geom_errorbar(aes(ymin=minT, ymax=maxT)) +
facet_grid(pol.type~sym.id)
tail(fit1summary)
nrow(fit1summary)
26216-258
fit1summary[25958:26215,1]
fit1summary[25959:26215,1]
fit1plotdat <- data.table(reg.id = levels(bern.exp$reg.id), meanT=fit1summary[25959:26215,1], minT=fit1summary[25959:26215,4], maxT=fit1summary[25959:26215,8])
fit1plotdat[,c('pol.type','sym.id','stepsleft'):=as.list(unlist(strsplit(reg.id, '[.]'))), by=.(reg.id)
][,stepsleft:=as.numeric(stepsleft)]
ggplot(fit1plotdat, aes(x=stepsleft, y=meanT, group=sym.id, col=sym.id))+
geom_line() +
geom_point() +
geom_errorbar(aes(ymin=minT, ymax=maxT)) +
facet_grid(pol.type~sym.id)
fit1summary
fit1plotdat <- data.table(reg.id = levels(bern.exp$reg.id), meanT=fit1summary[1:257,1], minT=fit1summary[1:257,4], maxT=fit1summary[1:257,8])
fit1plotdat[,c('pol.type','sym.id','stepsleft'):=as.list(unlist(strsplit(reg.id, '[.]'))), by=.(reg.id)
][,stepsleft:=as.numeric(stepsleft)]
ggplot(fit1plotdat, aes(x=stepsleft, y=meanT, group=sym.id, col=sym.id))+
geom_line() +
geom_point() +
geom_errorbar(aes(ymin=minT, ymax=maxT)) +
facet_grid(pol.type~sym.id)
fit1summary[258,]
fit1summary
rownames(fit1summary)
data.table(pp= rep(1:max(bern.exp$pp), each=length(levels(bern.exp$reg.id))), reg.id = rep(levels(bern.exp$reg.id), times=max(bern.exp$pp))
)
(258+length(levels(bern.exp$reg.id))*max(bern.exp$pp))
nrow(fit1summary)
26216-258
fit1pardat <-  data.table(pp= rep(1:max(bern.exp$pp), each=length(levels(bern.exp$reg.id))), reg.id = rep(levels(bern.exp$reg.id), times=max(bern.exp$pp)),
meanT=fit1summary[258:(258+length(levels(bern.exp$reg.id))*max(bern.exp$pp)),1],
minT =fit1summary[258:(258+length(levels(bern.exp$reg.id))*max(bern.exp$pp)),4],
maxT =fit1summary[258:(258+length(levels(bern.exp$reg.id))*max(bern.exp$pp)),8])
fit1pardat <-  data.table(pp= rep(1:max(bern.exp$pp), each=length(levels(bern.exp$reg.id))), reg.id = rep(levels(bern.exp$reg.id), times=max(bern.exp$pp)),
meanT=fit1summary[258:(259+length(levels(bern.exp$reg.id))*max(bern.exp$pp)),1],
minT =fit1summary[258:(259+length(levels(bern.exp$reg.id))*max(bern.exp$pp)),4],
maxT =fit1summary[258:(259+length(levels(bern.exp$reg.id))*max(bern.exp$pp)),8])
fit1pardat <-  data.table(pp= rep(1:max(bern.exp$pp), each=length(levels(bern.exp$reg.id))), reg.id = rep(levels(bern.exp$reg.id), times=max(bern.exp$pp)),
meanT=fit1summary[258:(257+length(levels(bern.exp$reg.id))*max(bern.exp$pp)),1],
minT =fit1summary[258:(257+length(levels(bern.exp$reg.id))*max(bern.exp$pp)),4],
maxT =fit1summary[258:(257+length(levels(bern.exp$reg.id))*max(bern.exp$pp)),8])
fit1pardat[,c('pol.type','sym.id','stepsleft'):=as.list(unlist(strsplit(reg.id, '[.]'))), by=.(reg.id)
][,stepsleft:=as.numeric(stepsleft)]
fit1pardat
ggplot(fit1plotdat, aes(x=stepsleft, y=meanT, group=sym.id, col=sym.id))+
geom_line() +
geom_line(data=fit1pardat, aes(x=stepsleft, y=meanT, group=sym.id, col=pp),col='gray', alpha=0.5) +
geom_point() +
geom_errorbar(aes(ymin=minT, ymax=maxT)) +
facet_grid(pol.type~sym.id)
ggplot(fit1plotdat, aes(x=stepsleft, y=meanT, group=sym.id, col=sym.id))+
geom_line() +
geom_line(data=fit1pardat, aes(x=stepsleft, y=meanT, group=interaction(sym.id,pp)),col='gray', alpha=0.5) +
geom_point() +
geom_errorbar(aes(ymin=minT, ymax=maxT)) +
facet_grid(pol.type~sym.id)
ggplot(fit1plotdat, aes(x=stepsleft, y=meanT, group=sym.id, col=sym.id))+
geom_line() +
geom_line(data=fit1pardat, aes(x=stepsleft, y=meanT, group=interaction(sym.id,pp)),col='gray', alpha=0.5) +
geom_point() +
geom_errorbar(aes(ymin=minT, ymax=maxT)) +
geom_errorbar(data=fit1pardat, aes(ymin=minT, ymax=maxT, group=interaction(sym.id,pp),x=stepsleft)) +
facet_grid(pol.type~sym.id)
ggplot(fit1plotdat, aes(x=stepsleft, y=meanT, group=sym.id, col=sym.id))+
geom_line() +
geom_line(data=fit1pardat, aes(x=stepsleft, y=meanT, group=interaction(sym.id,pp)),col='gray', alpha=0.5) +
geom_point() +
geom_errorbar(aes(ymin=minT, ymax=maxT)) +
geom_errorbar(data=fit1pardat, aes(ymin=minT, ymax=maxT, group=interaction(sym.id,pp),x=stepsleft),col='gray', alpha=0.5) +
facet_grid(pol.type~sym.id)
fit1
tail(fit1summary)
which(names(fit1summary)=='sigma')
which(names(fit1summary)=='sigma[1]')
which(names(fit1summary)=='theta[257')
names(fit1summary)
which(rownames(fit1summary)=='sigma')
fit1summary[26968,]
fit1summary[25958,]
as.matrix(fit1)
which(levels(bern.exp$wow))
levels(bern.exp$reg.id)
which(levels(bern.exp$reg.id)=='deep.c.3')
post.samps <- as.matrix(fit1)
post.samps[1,]
colnames(post.samps)
post.samps[,which(colnames(post.samps == paste('beta[', which(levels(bern.exp$reg.id)=='deep.c.3'), ']', sep='')))]
which(colnames(post.samps == paste('beta[', which(levels(bern.exp$reg.id)=='deep.c.3'), ']', sep='')))
which(levels(bern.exp$reg.id)=='deep.c.3')
paste('beta[', which(levels(bern.exp$reg.id)=='deep.c.3'), ']', sep='')
which(colnames(post.samps == paste('beta[', which(levels(bern.exp$reg.id)=='deep.c.3'), ']', sep='')))
post.samps
post.samps[,1]
plot(density(post.samps[,1]))
colnames(post.samps[,1])
colnames(post.samps)
colnames(post.samps)[1]
colnames(post.samps)[60]
which(levels(bern.exp$reg.id)=='deep.c.3')
post.samps[,which(levels(bern.exp$reg.id)=='deep.c.3')]
ggplot(fit1plotdat, aes(x=stepsleft, y=meanT, group=sym.id, col=sym.id))+
geom_line() +
geom_line(data=fit1pardat, aes(x=stepsleft, y=meanT, group=interaction(sym.id,pp)),col='gray', alpha=0.5) +
geom_point() +
geom_errorbar(aes(ymin=minT, ymax=maxT)) +
geom_errorbar(data=fit1pardat, aes(ymin=minT, ymax=maxT, group=interaction(sym.id,pp),x=stepsleft),col='gray', alpha=0.5) +
facet_grid(pol.type~sym.id)
which(levels(bern.exp$reg.id)=='deep.d.3')
post.samps[,which(levels(bern.exp$reg.id)=='deep.d.3')] - post.samps[,which(levels(bern.exp$reg.id)=='deep.c.3')]
plot(density(post.samps[,which(levels(bern.exp$reg.id)=='deep.d.3')] - post.samps[,which(levels(bern.exp$reg.id)=='deep.c.3')]))
install.packages("bayestestR")
mcmc_areas(post.samps, pars=c('beta[60]','beta[62]'), prob=0.8)
mcmc_areas(post.samps, pars=c('beta[60]','beta[62]'), prob=0.8)
save(fit1, file='output/parvar_model_save1.RData')
save(fit1, file='data/parvar_model_save1.RData')
Version()
R.Version()
