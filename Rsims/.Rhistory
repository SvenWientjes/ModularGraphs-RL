][,stepsleft := (if(TRUE %in% V1){
.SD[V1==T,max(steps)]
}else{
as.integer(0)
}),
by=vertex
]
EVmat.d[, EV<0,by=.(vertex,steps)
][,if(TRUE %in% V1){
.SD[V1==T,max(steps)]
}else{
as.integer(0)
},
by=vertex
]
stopIdx.d
EVmat.d
stopIdx.d
EVmat.d[vertex==5]
############################################################################################################################
########################## Script for playing around with gamble choices in the QuadSchap ##################################
############################################################################################################################
library(foreach)
library(ggplot2)
library(reshape2)
library(data.table)
# Load Functions from /src/
sapply(paste0('src/',list.files('src/')), source)
# Define point multiplier for winning
winM   <- 5
nVisit <- 15
nTr    <- 100
#Quad Schapiro-style edge matrix
Edges <- list(c(2, 3, 4, 20),
c(1, 3, 4, 5),
c(1, 2, 4, 5),
c(1, 2, 3, 5),
c(2, 3, 4, 6),
c(5, 7, 8, 9),
c(6, 8, 9, 10),
c(6, 7, 9, 10),
c(6, 7, 8, 10),
c(7, 8, 9, 11),
c(10,12,13,14),
c(11,13,14,15),
c(11,12,14,15),
c(11,12,13,15),
c(12,13,14,16),
c(15,17,18,19),
c(16,18,19,20),
c(16,17,19,20),
c(16,17,18,20),
c(17,18,19, 1))
# Get vertex / edge mappings w.r.t. different goals
idmap.d  <- list(a = c(1,15), b = c(2,3,4, 12,13,14), c = c(5,11), d = c(6,10), e = c(7,9), f = c(16,20), g = c(17,18,19))
idmap.bg <- list(a = c(1), b = c(2,3,4), c = c(5), d = c(7,8,9), e = c(10), f = c(11), g = c(12,13,14), h = c(15), i = c(16), j = c(17,18,19), k = c(20))
idmap.g  <- list(a = c(2,3,4), b = c(7,8,9), c = c(12,13,14), d = c(17,18,19))
c.map    <- list(a = c('d','b'), b = c('a', 'c'), c = c('b','d'), d=c('a','c'))
bt.map   <- list(a = c(1,5), b = c(6,10), c= c(11,15), d=c(20,16))
# Get hitMats
hitMat.d <- as.data.table(read.csv('data/hitMat_quadSchap_step15.csv', row.names=1))
hitMat.b <- as.data.table(read.csv('data/hitMat_quadSchap_step15_btgl.csv', row.names=1))
# Calculate EV for different nodes
EVmat.d <- foreach(v = unique(hitMat.d$vertex), .combine=rbind) %do% {
tempMat <- EVbet.calc(Edges=Edges, nSteps=nVisit-1, winM=winM, hitMat=hitMat.d, Vertex=v)
tempMat
}
EVmat.b <- foreach(v = unique(hitMat.b$vertex), .combine=rbind) %do% {
tempMat <- EVbet.calc(Edges=Edges, nSteps=nVisit-1, winM=winM, hitMat=hitMat.b, Vertex=v)
tempMat
}
EVmat.d
EVmat.b
# Get policies for the deep & bottleneck node EVmats
stopIdx.d <- EVmat.d[, EV<0,by=.(vertex,steps)
][,if(TRUE %in% V1){
.SD[V1==T,max(steps)]
}else{
as.integer(0)
},
by=vertex
]
stopIdx.b <- EVmat.b[, EV<0,by=.(vertex,steps)
][,if(TRUE %in% V1){
.SD[V1==T,max(steps)]
}else{
as.integer(0)
},
by=vertex
]
stopIdx.d
stopIdx.b
15:12
c(1,2,3,4)
15.4
15-4
Bet.gen <- function(Edges, nVisit, nTr, c.map, idmap.g, bt.map, parNum=1){
experiment <- data.table(pp = 0, tr = 0, stepsleft = 0, v = 0, goal=0, trtype='init')
for(tr in 1:nTr){
# Sample a start node
path <- sample(x=unique(unlist(Edges)), 1)
# Determine starting cluster
start.c <- names(sapply(idmap.g, function(m){path[1] %in% m})[which(sapply(idmap.g, function(m){path[1] %in% m}))])
if(identical(start.c, character(0))){
start.c <- names(sapply(bt.map, function(m){path[1] %in% m})[which(sapply(bt.map, function(m){path[1] %in% m}))])
}
# Sample a goal cluster and node from adjacent
if(path[1] %in% unlist(idmap.g)){
goal.c <- sample(c.map[sapply(idmap.g, function(m){path %in% m})][[1]],1)
}else if(path[1] %in% unlist(bt.map)){
goal.c <- sample(c.map[sapply(bt.map, function(m){path %in% m})][[1]],1)
}
goal <- sample(c(idmap.g[[goal.c]], bt.map[[goal.c]]), 1)
# Determine trial goal type (deep node or bottleneck as goal) (bottleneck close or far)
if(goal %in% unlist(idmap.g)){
goaltype = 'deep'
}else if(goal %in% unlist(bt.map) & bt.map[[goal.c]][which(c.map[[goal.c]]==start.c)]==goal){
goaltype = 'goalclose'
}else if(goal %in% unlist(bt.map) & !bt.map[[goal.c]][which(c.map[[goal.c]]==start.c)]==goal){
goaltype = 'goalfar'
}
# Generate a path
while(length(path) < nVisit & tail(path,1) != goal){
path <- c(path, sample(Edges[[tail(path,1)]],size=1))
}
experiment <- rbind(experiment, data.table(pp=parNum, tr=tr, stepsleft=(nVisit-1):(nVisit-length(path)), v=path, goal=goal, trtype=goaltype))
}
return(experiment[-1,])
}
Bet.gen(Edges, nSteps, nTr, c.map, idmap.g, bt.map)
Bet.gen(Edges, nVisit, nTr, c.map, idmap.g, bt.map)
stopIdx.b
Bet.gen(Edges, nVisit, nTr, c.map, idmap.g, bt.map)
############################################################################################################################
########################## Script for playing around with gamble choices in the QuadSchap ##################################
############################################################################################################################
library(foreach)
library(ggplot2)
library(reshape2)
library(data.table)
# Load Functions from /src/
sapply(paste0('src/',list.files('src/')), source)
# Define point multiplier for winning
winM   <- 5
nVisit <- 15
nTr    <- 100
#Quad Schapiro-style edge matrix
Edges <- list(c(2, 3, 4, 20),
c(1, 3, 4, 5),
c(1, 2, 4, 5),
c(1, 2, 3, 5),
c(2, 3, 4, 6),
c(5, 7, 8, 9),
c(6, 8, 9, 10),
c(6, 7, 9, 10),
c(6, 7, 8, 10),
c(7, 8, 9, 11),
c(10,12,13,14),
c(11,13,14,15),
c(11,12,14,15),
c(11,12,13,15),
c(12,13,14,16),
c(15,17,18,19),
c(16,18,19,20),
c(16,17,19,20),
c(16,17,18,20),
c(17,18,19, 1))
# Get vertex / edge mappings w.r.t. different goals
idmap.d  <- list(a = c(1,15), b = c(2,3,4, 12,13,14), c = c(5,11), d = c(6,10), e = c(7,9), f = c(16,20), g = c(17,18,19))
idmap.bg <- list(a = c(1), b = c(2,3,4), c = c(5), d = c(7,8,9), e = c(10), f = c(11), g = c(12,13,14), h = c(15), i = c(16), j = c(17,18,19), k = c(20))
idmap.g  <- list(a = c(2,3,4), b = c(7,8,9), c = c(12,13,14), d = c(17,18,19))
c.map    <- list(a = c('d','b'), b = c('a', 'c'), c = c('b','d'), d=c('a','c'))
bt.map   <- list(a = c(1,5), b = c(6,10), c= c(11,15), d=c(20,16))
# Get hitMats
hitMat.d <- as.data.table(read.csv('data/hitMat_quadSchap_step15.csv', row.names=1))
hitMat.b <- as.data.table(read.csv('data/hitMat_quadSchap_step15_btgl.csv', row.names=1))
# Calculate EV for different nodes
EVmat.d <- foreach(v = unique(hitMat.d$vertex), .combine=rbind) %do% {
tempMat <- EVbet.calc(Edges=Edges, nSteps=nVisit-1, winM=winM, hitMat=hitMat.d, Vertex=v)
tempMat
}
EVmat.b <- foreach(v = unique(hitMat.b$vertex), .combine=rbind) %do% {
tempMat <- EVbet.calc(Edges=Edges, nSteps=nVisit-1, winM=winM, hitMat=hitMat.b, Vertex=v)
tempMat
}
# Get policies for the deep & bottleneck node EVmats
stopIdx.d <- EVmat.d[, EV<0,by=.(vertex,steps)
][,if(TRUE %in% V1){
.SD[V1==T,max(steps)]
}else{
as.integer(0)
},
by=vertex
]
stopIdx.b <- EVmat.b[, EV<0,by=.(vertex,steps)
][,if(TRUE %in% V1){
.SD[V1==T,max(steps)]
}else{
as.integer(0)
},
by=vertex
]
## Get simulated trajectories ----
Bet.gen(Edges, nVisit, nTr, c.map, idmap.g, bt.map)
full.exp <- Bet.gen(Edges, nVisit, nTr, c.map, idmap.g, bt.map)
full.exp
full.exp[tr==1,]
full.exp[tr==1, ]
full.exp[tr==1, choice=1]
full.exp[tr==1, choice:=1]
full.exp[tr==1,]full.exp
full.exp
sample(-1,1)
sample(-1,1)
sample(-1,1)
sample(-1,1)
sample(-1,1)
sample(c(-1,1),1)
sample(c(-1,1),1)
sample(c(-1,1),1)
sample(c(-1,1),1)
full.exp[, choice:=sample(c(-1,1),1), by=.(tr,stepsleft)]
full.exp
full.exp <- Bet.gen(Edges, nVisit, nTr, c.map, idmap.g, bt.map)
full.exp[, randomchoice:=sample(c(-1,1),1), by=.(tr,stepsleft)]
full.exp
full.exp[, randomchoice:=sample(c(-1,1),1), by=.(tr,stepsleft)][,trRew := 0,by=tr]
full.exp
full.exp <- Bet.gen(Edges, nVisit, nTr, c.map, idmap.g, bt.map)
full.exp[, randomchoice:=sample(c(-1,1),1), by=.(tr,stepsleft)][,trRew := sum(randomchoice),by=tr]
full.exp
full.exp <- Bet.gen(Edges, nVisit, nTr, c.map, idmap.g, bt.map)
stopIdx.d
EVmat.d
full.exp
Bet.gen <- function(Edges, nVisit, nTr, c.map, idmap.g, bt.map, parNum=1){
experiment <- data.table(pp = 0, tr = 0, stepsleft = 0, v = 0, goal=0, trtype='init')
for(tr in 1:nTr){
# Sample a start node
path <- sample(x=unique(unlist(Edges)), 1)
# Determine starting cluster
start.c <- names(sapply(idmap.g, function(m){path[1] %in% m})[which(sapply(idmap.g, function(m){path[1] %in% m}))])
if(identical(start.c, character(0))){
start.c <- names(sapply(bt.map, function(m){path[1] %in% m})[which(sapply(bt.map, function(m){path[1] %in% m}))])
}
# Sample a goal cluster and node from adjacent
if(path[1] %in% unlist(idmap.g)){
goal.c <- sample(c.map[sapply(idmap.g, function(m){path %in% m})][[1]],1)
}else if(path[1] %in% unlist(bt.map)){
goal.c <- sample(c.map[sapply(bt.map, function(m){path %in% m})][[1]],1)
}
goal <- sample(c(idmap.g[[goal.c]], bt.map[[goal.c]]), 1)
# Determine trial goal type (deep node or bottleneck as goal) (bottleneck close or far)
if(goal %in% unlist(idmap.g)){
goaltype = 'deep'
}else if(goal %in% unlist(bt.map) & bt.map[[goal.c]][which(c.map[[goal.c]]==start.c)]==goal){
goaltype = 'goalclose'
}else if(goal %in% unlist(bt.map) & !bt.map[[goal.c]][which(c.map[[goal.c]]==start.c)]==goal){
goaltype = 'goalfar'
}
# Generate a path
while(length(path) < nVisit & tail(path,1) != goal){
path <- c(path, sample(Edges[[tail(path,1)]],size=1))
}
experiment <- rbind(experiment, data.table(pp=parNum, tr=tr, stepsleft=(nVisit-1):(nVisit-length(path)), v=path, goal=goal, trtype=goaltype))
}
return(experiment[-1,])
}
full.exp <- Bet.gen(Edges, nVisit, nTr, c.map, idmap.g, bt.map)
full.exp
full.exp
full.exp[, randomchoice:=sample(c(-1,1),1), by=.(tr,stepsleft)]
full.exp
cumsum(c(1,2,3,4,5))
full.exp <- Bet.gen(Edges, nVisit, nTr, c.map, idmap.g, bt.map)
full.exp[, randomchoice:=sample(c(-1,1),1), by=.(tr,stepsleft)][,trBet := cumsum(randomchoice),by=tr]
full.exp
full.exp <- Bet.gen(Edges, nVisit, nTr, c.map, idmap.g, bt.map)
full.exp[, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)][,rand.trBet := cumsum(randomchoice),by=tr]
full.exp <- Bet.gen(Edges, nVisit, nTr, c.map, idmap.g, bt.map)
full.exp[, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)][,rand.trBet := cumsum(rand.choice),by=tr]
full.exp
full.exp[, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)][,rand.trBet := cumsum(rand.choice)+5,by=tr]
full.exp
full.exp
full.exp <- Bet.gen(Edges, nVisit, nTr, c.map, idmap.g, bt.map)
full.exp[tr==1]
full.exp[tr==2]
full.exp[tr==3]
full.exp[tr==4]
full.exp[tr==5]
full.exp[tr==6]
full.exp[tr==7]
full.exp[tr==8]
full.exp[tr==9]
full.exp[tr==10]
full.exp[tr==11]
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := cumsum(rand.choice)+5,by=tr
]
full.exp
full.exp[tr==11]
c(1,2,3,4)
c(1,2,3,4,NA)
na.omit(c(1,2,3,4,NA))
cumsum(na.omit(c(1,2,3,4,NA)))
?na.omit
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := cumsum(rand.choice)+5,by=tr
]
full.exp
full.exp[tr==11]
library(zoo)
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := cumsum(na.locf(rand.choice))+5,by=tr
]
full.exp
full.exp[tr==11]
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
]
full.exp[tr==11]
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
][stepsleft==min(stepsleft),rand.trRew := 0, by=tr
]
full.exp
full.exp[tr==11]
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
][stepsleft==min(.SD[,stepsleft]),rand.trRew := 0, by=tr
]
full.exp[tr==1 & stepsleft==1]
full.exp[tr==1 & stepsleft==1,stepsleft]
full.exp[tr==1]
full.exp[tr==1,min(stepsleft)]
full.exp[tr==11,min(stepsleft)]
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
][stepsleft==.SD[,min(stepsleft)],rand.trRew := 0, by=tr
]
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
][,rand.trRew := tr, by=tr
]
full.exp
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
][stepsleft == full.exp[tr==tr,min(stepsleft)],rand.trRew := tr, by=tr
]
full.exp
full.exp[tr==1,min(stepsleft)]
full.exp[tr==11,min(stepsleft)]
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
][stepsleft == min(full.exp[tr==tr,stepsleft]), rand.trRew := tr, by=tr
]
full.exp
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
][stepsleft == .N, rand.trRew := tr, by=tr
]
full.exp
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
][stepsleft == 1, rand.trRew := tr, by=tr
]
full.exp
full.exp <- Bet.gen(Edges, nVisit, nTr, c.map, idmap.g, bt.map)
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
][stepsleft == 1, rand.trRew := tr, by=tr
]
full.exp
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
][stepsleft == min(full.exp[tr==tr,stepsleft]), rand.trRew := tr, by=tr
]
full.exp
full.exp <- Bet.gen(Edges, nVisit, nTr, c.map, idmap.g, bt.map)
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
][stepsleft == min(full.exp[tr==tr,stepsleft]), rand.trRew := tr, by=tr
]
full.exp
full.exp[tr==1]
full.exp[tr==2]
full.exp[tr==3]
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
][stepsleft == full.exp[tr==tr,min(stepsleft)], rand.trRew := tr, by=tr
]
full.exp[tr==3]
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
][stepsleft == 0, rand.trRew := -rand.trBet, by=tr
]
full.exp
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
][stepsleft == 0, rand.trRew := -rand.trBet, by=tr
][v==goal, rand.trRew := winM*rand.trBet, by=tr]
full.exp[tr==3]
full.exp[tr==2]
# Define random strategy
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
][stepsleft == 0, rand.trRew := -rand.trBet, by=tr
][v==goal, rand.trRew := winM*rand.trBet, by=tr
][,rand.totRew := cumsum(rand.trRew)]
full.exp
is.na(NA)
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
][stepsleft == 0, rand.trRew := -rand.trBet, by=tr
][v==goal, rand.trRew := winM*rand.trBet, by=tr
][!is.na(rand.trRew),rand.totRew := cumsum(rand.trRew)]
full.exp
full.exp[tr==1]
full.exp[tr==2]
full.exp[tr==3]
full.exp[tr==4]
full.exp$rand.trBet
max(c(5,4))
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := max(na.locf(cumsum(rand.choice))+5,0),by=tr
][stepsleft == 0, rand.trRew := -rand.trBet, by=tr
][v==goal, rand.trRew := winM*rand.trBet, by=tr
][!is.na(rand.trRew),rand.totRew := cumsum(rand.trRew)]
full.exp$rand.trBet
# Define random strategy
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,0,by=tr
][stepsleft == 0, rand.trRew := -rand.trBet, by=tr
][v==goal, rand.trRew := winM*rand.trBet, by=tr
][!is.na(rand.trRew),rand.totRew := cumsum(rand.trRew)]
## Get simulated trajectories ----
# Initialize experimental experience
full.exp <- Bet.gen(Edges, nVisit, nTr, c.map, idmap.g, bt.map)
# Define random strategy
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,0,by=tr
][stepsleft == 0, rand.trRew := -rand.trBet, by=tr
][v==goal, rand.trRew := winM*rand.trBet, by=tr
][!is.na(rand.trRew),rand.totRew := cumsum(rand.trRew)]
# Define random strategy
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
][stepsleft == 0, rand.trRew := -rand.trBet, by=tr
][v==goal, rand.trRew := winM*rand.trBet, by=tr
][!is.na(rand.trRew),rand.totRew := cumsum(rand.trRew)]
full.exp
full.exp$rand.trBet
# Define random strategy
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
][rand.trBet<0, rand.trBet:=0
][stepsleft == 0, rand.trRew := -rand.trBet, by=tr
][v==goal, rand.trRew := winM*rand.trBet, by=tr
][!is.na(rand.trRew),rand.totRew := cumsum(rand.trRew)]
full.exp$rand.trBet
# Define random strategy
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
][stepsleft == 0, rand.trRew := -rand.trBet, by=tr
][v==goal, rand.trRew := winM*rand.trBet, by=tr
][!is.na(rand.trRew),rand.totRew := cumsum(rand.trRew)]
full.exp
full.exp$rand.trBet
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)
][,rand.trBet := na.locf(cumsum(rand.choice))+5,by=tr
]
full.exp
full.exp$rand.trBet
full.exp[rand.trBet<0, rand.trBet:=0]
full.exp
full.exp$rand.trBet
startP <- 5
# Define random strategy
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)         #Sample random choice increments
][,rand.trBet := na.locf(cumsum(rand.choice))+startP,by=tr               #Add up to get bets, with 5 starting points
][rand.trBet<0, rand.trBet:=0
][stepsleft == 0, rand.trRew := -rand.trBet, by=tr
][v==goal, rand.trRew := winM*rand.trBet, by=tr
][!is.na(rand.trRew),rand.totRew := cumsum(rand.trRew)]
full.exp$rand.trBet
full.exp
full.exp$rand.totRew
full.exp[tr==1]
hitMat.d
hitMat.d[vertex==2]
hitMat.d[vertex==2,cumsum(goalprob)]
hitMat.b[vertex==2,cumsum(goalprob)]
hitMat.b[vertex==5,cumsum(goalprob)]
hitMat.b[vertex==1,cumsum(goalprob)]
hitMat.b[vertex==10,cumsum(goalprob)]
hitMat.b[vertex==7,cumsum(goalprob)]
hitMat.b[vertex==5,cumsum(goalprob)]
hitMat.b[vertex==11,cumsum(goalprob)]
hitMat.b[vertex==12,cumsum(goalprob)]
hitMat.b[vertex==15,cumsum(goalprob)]
## Get simulated trajectories ----
# Initialize experimental experience
full.exp <- Bet.gen(Edges, nVisit, nTr, c.map, idmap.g, bt.map)
# Define random strategy
full.exp[v!=goal, rand.choice:=sample(c(-1,1),1), by=.(tr,stepsleft)         #Sample random choice increments
][,rand.trBet := na.locf(cumsum(rand.choice))+startP,by=tr          #Add up to get bets, with 5 starting points
][rand.trBet<0, rand.trBet:=0                                     #Cannot bet below zero
][stepsleft == 0, rand.trRew := -rand.trBet, by=tr              #Determine losing bets
][v==goal, rand.trRew := winM*rand.trBet, by=tr               #Determine winning bets
][!is.na(rand.trRew),rand.totRew := cumsum(rand.trRew)]     #Add up all losses and wins
full.exp
